{"meta":{"title":"wang's dayliy document","subtitle":null,"description":null,"author":"Kuiq  Wang","url":"http://www.wqkenqing.ren/daydoc","root":"/daydoc/"},"pages":[{"title":"tags","date":"2020-05-22T02:42:26.000Z","updated":"2020-05-27T06:39:23.660Z","comments":true,"path":"tags/index.html","permalink":"http://www.wqkenqing.ren/daydoc/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-22T02:41:30.000Z","updated":"2020-05-27T06:39:23.660Z","comments":true,"path":"categories/index.html","permalink":"http://www.wqkenqing.ren/daydoc/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"python 小结2","slug":"日常总结/编程/python","date":"2020-05-24T16:00:00.000Z","updated":"2020-05-26T14:32:28.151Z","comments":true,"path":"2020/05/25/日常总结/编程/python/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/25/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E7%BC%96%E7%A8%8B/python/","excerpt":"","text":"python中的变量创建 python 变量命名 多个变量赋值 列表与元组 列表 如何访问列表中的值 列表运算符 元组(tuple) 创建元组 访问元组 dict(字典) 什么是字典 字典的创建 set() 什么是set set的创建 函数 什么是函数 自定义函数的创建 函数的返回值 函数的参数 位置参数 不定长参数 只接受关键字参数 迭代器与生成器 面向对象 类的定义与调用 python中的变量创建python 变量命名在 Python 程序中，变量是用一个变量名表示，可以是任意数据类型，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头 多个变量赋值eg:a=b=c=1 eg:a,b,c=1,2,”the is varible” 列表与元组 列表eg: list1=[“1”,2,”three”] 即列表名,’[]’ 列表符组成 列表中的元素类型可以不一致. 如何访问列表中的值 通过索引下标来访问 即已知索引长度为3 我们可以通过list1[i] i为0~2之间的整数 这与java中的数组类似 2.通过下标区间来访问 如 list1[0:2]可以取到list[0],list[1]这里是因为[0:2]是左闭右开的 ` 列表运算符 Python 表达式 结果 描述 len(list1) 3 list的长度 [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] 组合 [“yes”]*2 [“yes”,”yes”] 复制 2 in [1,2,3] True 元素是否存在于列表中 for a in list : function 迭代 一些常见的方法 元组(tuple)uple 一旦初始化就不能修改。 也就是说元组（tuple）是不可变的，那么不可变是指什么意思呢？即声明元组后,只可获取相应的内容,但不能再通过insert ,append ,pop,remove等方法再操作其内容 创建元组tuple1=(1,”2”,”three”) 空元组tuple2=() 访问元组 dict(字典)什么是字典类似java中的map key-val形式 字典的创建dict={“key1”:”val1”,”key2”:”val2”} set()什么是setset与java中的set异同,这里是一个无序不重复的元素集,基本功能包括数据存放与消除重复元素 set的创建创建一个set,需要提供一个list 函数什么是函数类比java里的方法 自定义函数的创建def functionName(): methodBody return 没有return 则自动返回None 函数的返回值不带参数值的 return 语句返回 None。 通过return即可返回 同时还可以返回多个返回值,通过逗 号分隔,即以元组的形式返回 Python 一次接受多个返回值的数据类型就是元组。 函数的参数 默认参数 关键字参数(位置参数) 不定长参数 当你设置了默认参数的时候，在调用函数的时候，不传该参数，就会使用默认值 只有在形参表末尾的那些参数可以有默认参数值，也就是说你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。这是因为赋给形参的值是根据位置而赋值的。例如，def func(a, b=1) 是有效的，但是 def func(a=1, b) 是 无效 的。 位置参数不定长参数*arg 一个元组的形式 **arg 支持关键字参数,没有被定义的参数会被放到一个字典里. 只接受关键字参数将强制关键字参数放到某个参数或者单个后面就能达到这种效果 迭代器与生成器面向对象类的定义与调用","categories":[],"tags":[{"name":"python learn","slug":"python-learn","permalink":"http://www.wqkenqing.ren/daydoc/tags/python-learn/"}]},{"title":"es添加字段并赋值","slug":"日常总结/运维/es添加字段和默认值","date":"2020-05-21T16:00:00.000Z","updated":"2020-05-26T14:32:28.134Z","comments":true,"path":"2020/05/22/日常总结/运维/es添加字段和默认值/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/22/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/es%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC/","excerpt":"","text":"添加字段即 1234PUT /index/_mapping&#123; ...&#125; 1给es添加字段 这里主要通过script脚本.并且在elasticsearch1.3后这个默认配置是被关掉的. 即在elasticsearch.yml中添加script.inline=truescript.indexed=true一开始我在true后面加了空格,配置不被识别,所以这里要注意 开启了script.line后通过update_by_query进行操作,这里注意以下写法已经过时 12345678POST /index/_update_by_query?conflicts=proceed&#123; \"script\":&#123; \"lang\":\"painless\", \"inline\": \"ctx._source.name='trhee'\" &#125;&#125; 即inline这种写法已经过时. 现在主要用的是source 1234567POST /index/_update_by_query?conflicts=proceed&#123; \"script\":&#123; \"lang\":\"painless\", \"source\": \"ctx._source.name='trhee'\" &#125;&#125; 还能加入条件判断 1234567POST /index/_update_by_query?conflicts=proceed&#123; \"script\":&#123; \"lang\":\"painless\", \"source\": \"if(ctx._source.name=='')&#123;ctx._source.name='trhee'&#125;\" &#125;&#125; 至此即可以实现对_source.name字段的数据进行默认赋值","categories":[],"tags":[{"name":"es feild script","slug":"es-feild-script","permalink":"http://www.wqkenqing.ren/daydoc/tags/es-feild-script/"}]},{"title":"es常用操作工具","slug":"日常总结/es/es常用操作工具","date":"2020-05-20T16:00:00.000Z","updated":"2020-05-26T14:32:28.158Z","comments":true,"path":"2020/05/21/日常总结/es/es常用操作工具/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/21/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/es/es%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7/","excerpt":"es操作工具","text":"es操作工具 1es常用的操作工具介绍 elasticsearch-headelascticsearch-head是一款操作工具,这里不过多介绍,我日常使用较少,但这个工具有一个好处就是有对应的chrome插件,在非常用电脑上有相关需求时,可以通过登陆chrome账号就使用head插件应急 kibanakibana是elastic stack集成产中.一开始主要就是作为elasticsearch可视化需求的一个承载体,后续才单独拆开,承担了更多复杂的view功能 结合对应版本的elasticsearch部署对应的kibana版本后,即可开箱使用,这里不过多介绍具体使用细节.主要是说明下功能内容 Dev Tools模块用来写DSL语句,管理elasticsearch Management 模块kibana集成的理管模块,能对index进行一些管理操作. vscode前两者都是主流的elasticsearch的管理和操作工具,但实集使用过程中,特别是大量的DSL语句操作的时候,前两者虽然功能较全, 但操作是不方便的.因为如果把DSL比作是sql的话,在网页中书写DSL,量一大,一是语句的备份不好管理,相关内容太多,不能分类存放,容易造成误操作. 而vscode的插件库里有与elasticsearch结合的插件,这里elasticsearch for vscode 安装好后,即可开箱使用.只需要将文件创建为*.es的后缀.然后设置需要启用的elasticsearch的hostp:port 设置好后,即可在vscode 下的es文件中开始写对应的dsl语句. 极为方便,而且能在某文件内容过多后,轻易的再另起一个es文件.方便维护管理","categories":[],"tags":[{"name":"elasticsearch kibana head vscode","slug":"elasticsearch-kibana-head-vscode","permalink":"http://www.wqkenqing.ren/daydoc/tags/elasticsearch-kibana-head-vscode/"}]},{"title":"vscode插件","slug":"日常总结/运维/vscode插件","date":"2020-05-20T16:00:00.000Z","updated":"2020-05-26T14:32:28.135Z","comments":true,"path":"2020/05/21/日常总结/运维/vscode插件/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/21/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/vscode%E6%8F%92%E4%BB%B6/","excerpt":"","text":"vscode插件draw.io(思维导图)在应用商店搜索Draw.io Integration 并install即可安装draw.io 然后创建drawio后缀的文件即可使用对应的导图功能 这个好处是免费并与vscode集成.即实现all in one 的功能","categories":[],"tags":[{"name":"elasticsearch drawio","slug":"elasticsearch-drawio","permalink":"http://www.wqkenqing.ren/daydoc/tags/elasticsearch-drawio/"}]},{"title":"阿里云DDNS[转载]","slug":"日常总结/运维/阿里云DDNS","date":"2020-05-19T16:00:00.000Z","updated":"2020-05-26T14:32:28.135Z","comments":true,"path":"2020/05/20/日常总结/运维/阿里云DDNS/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/20/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/%E9%98%BF%E9%87%8C%E4%BA%91DDNS/","excerpt":"阿里云DDNS","text":"阿里云DDNS 阿里云DDNS1因为电信带宽的动态ip的问题,域名解析时常失效,所以用到这里的DDNS 自己带宽的设置略过. 前提准备 阿里云accesskyes配置 能运行docker镜像的服务器 docker镜像 阿里云 accesskeys申请登陆,点击右侧头像选择accesskeys即可. 获得ID与scret内容 docker容器下载https://hub.docker.com/r/chenhw2/aliyun-ddns-cli/ 1docker pull chenhw2&#x2F;aliyun-ddns-cli 启动容器 12345678docker run -d \\ --restart&#x3D;always \\ --name ddns-aliyun \\ -e &quot;AKID&#x3D;131323131231212&quot; \\ -e &quot;AKSCT&#x3D;dsfasfwerwefdfsfsdfsfs&quot; \\ -e &quot;DOMAIN&#x3D;dev.foxwho.com&quot; \\ -e &quot;REDO&#x3D;600&quot; \\ chenhw2&#x2F;aliyun-ddns-cli 容器启动成功后，你可以看看 域名解析是否已经自动更新解析IP 原文地址","categories":[],"tags":[{"name":"DDNS","slug":"DDNS","permalink":"http://www.wqkenqing.ren/daydoc/tags/DDNS/"}]},{"title":"杂记(操作系统)","slug":"日常总结/运维/杂记(操作系统使用体验)","date":"2020-05-19T16:00:00.000Z","updated":"2020-05-26T14:32:28.133Z","comments":true,"path":"2020/05/20/日常总结/运维/杂记(操作系统使用体验)/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/20/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/%E6%9D%82%E8%AE%B0(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C)/","excerpt":"","text":"从小学二年级接触windowsNT到大学毕业拥有自己第一台mac之前，一直是windows用户。windows版本基本也用NT-&gt;xp-&gt;win7-&gt;win8-&gt;w10等主要系统版本。使用场景也从文本编辑，软件应用，游戏，编程等多个场景。 因为参加工作，需要接触linux等原因，了解到了macos ,也在参加工作不久后入手了一台mbp。当时考虑的主要应用场景还是工作，编码和一些视频需求。 简单下来，对mac os 与windows有一些使用层面上的简单感受，所以开篇记录一番 主要诱因是因为最近一番调研下来发现还是windows阵营中的电脑较为好配，简单来讲就是一笔相对容易接受的价格就能在windows阵营配置下一台更方面硬件都相当不错的电脑。在这种情况影响用户体验的主要就是系统了。而综上，windows系统主要的差异点于mac比较来看的话是于系统操作的便捷性，与linux和unix内核下文件系统的差异性，并且在这之下的编程体验的不同。 而这里的编程体验，与系统的干净性，通过一些操作，如今已经能找到处理方案，所以现在我想尝试去再熟悉windows的操作。方便以后的换机时的选择。 to be continue!","categories":[],"tags":[{"name":"mac os & windows","slug":"mac-os-windows","permalink":"http://www.wqkenqing.ren/daydoc/tags/mac-os-windows/"}]},{"title":"tmux上手[转载]","slug":"日常总结/运维/tmux上手","date":"2020-05-18T16:00:00.000Z","updated":"2020-05-26T14:32:28.133Z","comments":true,"path":"2020/05/19/日常总结/运维/tmux上手/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/19/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/tmux%E4%B8%8A%E6%89%8B/","excerpt":"此处是简介","text":"此处是简介 mac os 通过 brew install tmux 1tmux 接收快捷键的指令是 ^ + B 即mac中的control + B 窗格的操作 1这些操作都是通过 ^+b 来接收 操作符 作用 % 左右创建两个窗格 ‘’ 左右创建两个窗格 x 关闭当前窗格 { 前移当前窗格 } 后移当前窗格 ; 选择上次用的窗格 o 选择下一个窗格 space 切换窗格布局 z 放大窗格 q 显示序号 窗口操作tmux 除了窗格以外，还有窗口（window） 的概念。依次使用以下快捷键来熟悉 tmux 的窗口操作： c 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态 p 切换至上一窗口 n 切换至下一窗口 w 窗口列表选择，注意 macOS 下使用 ⌃p 和 ⌃n 进行上下选择 &amp; 关闭当前窗口 , 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id 0 切换至 0 号窗口，使用其他数字 id 切换至对应窗口 f 根据窗口名搜索选择窗口，可模糊匹配 会话操作如果运行了多次 tmux 命令则会开启多个 tmux 会话（session）。在 tmux 会话中，使用前缀快捷键 ⌃b 配合以下快捷键可操作会话： $ 重命名当前会话 s 选择会话列表 d detach 当前会话，运行后将会退出 tmux 进程，返回至 shell 主进程 在 shell 主进程下运行以下命令可以操作 tmux 会话： 在 shell 主进程下运行以下命令可以操作 tmux 会话： 123456tmux new -s foo # 新建名称为 foo 的会话tmux ls # 列出所有 tmux 会话tmux a # 恢复至上一次的会话tmux a -t foo # 恢复名称为 foo 的会话，会话默认名称为数字tmux kill-session -t foo # 删除名称为 foo 的会话tmux kill-server # 删除所有的会话 原文连接","categories":[],"tags":[{"name":"tmux","slug":"tmux","permalink":"http://www.wqkenqing.ren/daydoc/tags/tmux/"}]},{"title":"cvim f失灵问题修复","slug":"日常总结/运维/cvim f失灵问题修复","date":"2020-05-18T16:00:00.000Z","updated":"2020-05-26T14:32:28.134Z","comments":true,"path":"2020/05/19/日常总结/运维/cvim f失灵问题修复/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/19/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/cvim%20f%E5%A4%B1%E7%81%B5%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/","excerpt":"此处是简介","text":"此处是简介 1cvim突然失灵,调试发现是js版本问题.cvim插件发行版暂未解决该问题.但有对应的修复分支 问题修复 one : 克隆库: https://github.com/antonioyon/chromium-vim/tree/issue-716-fix-broken-hints two: 切换分支到 issue-716-fix-broken-hints three: 若无npm 则先安装npm four: npm install , make five: chrome 地址栏输入 chrome://extensions .选择加载已解压文件 six: 刷新页面,检查是否已经生效","categories":[],"tags":[{"name":"cvim","slug":"cvim","permalink":"http://www.wqkenqing.ren/daydoc/tags/cvim/"}]},{"title":"kafka学习","slug":"日常总结/kafka/kafka实现","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.154Z","comments":true,"path":"2020/05/11/日常总结/kafka/kafka实现/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/kafka/kafka%E5%AE%9E%E7%8E%B0/","excerpt":"[ x ] Consumer Group里只会被某一个Consumer消费 ,Kafka还允许不同Consumer Group同时消费同一条消息，这一特性可以为消息的多元化处理提供支持。","text":"[ x ] Consumer Group里只会被某一个Consumer消费 ,Kafka还允许不同Consumer Group同时消费同一条消息，这一特性可以为消息的多元化处理提供支持。 kafka 发送模式通过producer.type设置,可以设置producer的发送模式,具体参数据有producer.type=false即同步(默认就是同步),设置为true为异步,即以batch形式像broker发送信息.(这里的batch可以设置)还有一种oneway.即通过对ack的设置即可实现,ack=0时,即为oneway,只管发,不管是否接收成功.-1则是全部副本接收成功才算成功. kakfa消费模式 at last one at most one exactly one","categories":[],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://www.wqkenqing.ren/daydoc/tags/kafka/"}]},{"title":"Lambda&Stream.md","slug":"日常总结/old/Lamda积累","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.149Z","comments":true,"path":"2020/05/11/日常总结/old/Lamda积累/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/Lamda%E7%A7%AF%E7%B4%AF/","excerpt":"Lambda&amp;Stream积累","text":"Lambda&amp;Stream积累 LambdaLambda主要是一个类语法长糖,尽量为java引入函数编程等实现,细节后续再补充 Streamjava8提拱的新特性之一就有stream.stream主要是针对集合的处理类.提供了一系列集合处理方式.配合使用lambda写出简介优美的代码 Stream的使用通过如 123456List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.stream();//即可以开启串行流;list.parallelStream().filter(a -&gt; &#123; return a &gt; 20; &#125;);//开启并行流 串行流即内部单线程顺序执行,并行则是启用多线程执行.后者并不一定效率就比前者高.因为并行执行启用分配线程资源时同样要消耗时间和资源,在一定量级下,前者的执行效率一度要高过后者. 我这里对三种对集合的处理形式的比较,可以简单参考一下 stream 串行流 parallelStream 并行流 常规循环式 12345678910111213141516171819202122232425262728293031List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100000; i++) &#123; list.add(getRandomNum()); &#125; DateUtil.setBegin(); list.stream().filter(a -&gt; &#123; return a &gt; 20; &#125;); DateUtil.setStop(); System.out.println(\"串行耗时\"+DateUtil.calCostTime()); DateUtil.setBegin(); list.parallelStream().filter(a -&gt; &#123; return a &gt; 20; &#125;); DateUtil.setStop(); System.out.println(\"并行耗时\"+DateUtil.calCostTime()); int count = 0; DateUtil.setBegin(); for (int l : list) &#123; if (l &gt; 20) &#123; count++; &#125; &#125; DateUtil.setStop(); System.out.println(\"循环耗时\"+DateUtil.calCostTime()); 经由相当量次的测试后,我觉得如果要对集合中的数据进行遍历操作,根据量级的不同,建议低量级还是采用普通循环,量级特别大,可考虑用并行流.书写方便,又不是大批量数据处理操作可以直接采用串行流 Stream的操作分类 Intermediate Terminal Short-circuiting","categories":[],"tags":[{"name":"日常总结","slug":"日常总结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"}]},{"title":"kafka","slug":"日常总结/old/kafka","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.140Z","comments":true,"path":"2020/05/11/日常总结/old/kafka/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/kafka/","excerpt":"kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic sparkstreamingkafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic flumetest","text":"kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic sparkstreamingkafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic flumetest kafka-console-producer.sh –broker-list localhost:9092 –topic flumetest :创建生产者 kafka-console-consumer.sh –bootstrap-server namenode:9092 –topic flume-ng Kafka相关小结kafka 相关指令kafka-server-start.sh config/server.properties &amp; 启动kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic topic_name :创建topickafka-console-producer.sh –broker-list localhost:9092 –topic topic_name :创建生产者 kafka-console-consumer.sh –bootstrap-server localhost:9092 –topic topic_name :创建消费者 kafka-console-producer.sh –broker-list namenode:9092 –topic sparkstreaming 删除group kafka-consumer-groups –bootstrap-server 192.168.10.100:9092,192.168.10.101:9092,192.168.10.102:9092 —group traffic_history —delete kafka java apikafka 虽然搭建较为简单,但想要对针它编程体验还是有些问题.初步使用下来明显感觉对版本的强约束性.以我线上版本 为例,我java项目对应的版本则是 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.10&lt;/artifactId&gt; &lt;version&gt;0.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;0.8.2.1&lt;/version&gt; &lt;/dependency&gt; 以上版本搭配经由我亲测通过","categories":[],"tags":[{"name":"kafka","slug":"kafka","permalink":"http://www.wqkenqing.ren/daydoc/tags/kafka/"}]},{"title":"mapreduce组件总结","slug":"日常总结/old/mapreduce组件总结","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.147Z","comments":true,"path":"2020/05/11/日常总结/old/mapreduce组件总结/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/mapreduce%E7%BB%84%E4%BB%B6%E6%80%BB%E7%BB%93/","excerpt":"mapreduce组件总结","text":"mapreduce组件总结 相关组件大致有 Inputformat Inputsplit ReadRecorder mapper Combiner Partioner Reduce GroupComparator Reduce shuffle 1shuffle 被称为mapreduce的核心,一个真正让奇迹发生的地方.但它到底是什么呢?简练的讲,它就是 map out 到 reduce in 这段过程中对数据的处理过程. shuffle过程中主要发生的操作有,Partion,Sort,spill,merge,copy,sort,merge.(还有可能有combine操作) 具体流程是map out后,Collector 对out后的数据进行处理. 数据将会写入到内存缓冲区,该内存缓冲区的数据达到80%后,会开启一个溢写线程,在磁盘本地创建一个文件.如果reduce设置了多个分区,写入buffer区的数据,会被打上一个分区标记.通过sortAndSpill()方法进行指对数据按分区号,key排序.最后溢出的文件是分区的,按key有序的文件.若buffer区中的20%一直未被填满,buffer写入进程不会断.但若达到100%,Buffer写入进程则会阻塞.并在buffer区中的数据全部spill完后才会再开启. (buffer区的内存默认是100M),spill过程中,若设置过combiner.则会对数据先进行combiner逻辑处理,再将处理后的数据写出 spill完成后则会对本地的spill后的文件进行Merge.即把多个spill后的文件进行合并,并排序.最后会行成一个有序文件 当1个Map Task 完成后,reduce 就会开启copy进程(默认是5个线程).这个过程中会通过http请求去各taskTracker(nodemanager),拉取相应的spill&amp;merge后的文件.当copy完成后,则又会对数据进行merge.这个过程中同样有个类似map shuffle 中的buffer 溢写的阶段. 这个过程同样会触发combiner组件.这里的merge数据源有三种 memory to memory memory to disk disk to disk默认1是不开启的. copy phase 完成后,是reduceTask 中的 sort phase即对merge 中的文件继续进行sort and group . 当sort phase 完成.则开启reduce phase .到此shuffle正式完成. ##二次排序 12 mapreduce 常见的辅助排序 partitioner key的比较Comparator 分组函数Grouping Comparator joinmap join ,semi join ,reduce join","categories":[],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"http://www.wqkenqing.ren/daydoc/tags/bigdata/"}]},{"title":"spark go on","slug":"日常总结/old/spark学习3","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.148Z","comments":true,"path":"2020/05/11/日常总结/old/spark学习3/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/spark%E5%AD%A6%E4%B9%A03/","excerpt":"spark-core,spark-streaming再深造","text":"spark-core,spark-streaming再深造 spark go on初始规划 spark-corespark-streaming","categories":[],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"http://www.wqkenqing.ren/daydoc/tags/bigdata/"}]},{"title":"大数据分享","slug":"日常总结/old/大数据相关分享","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.149Z","comments":true,"path":"2020/05/11/日常总结/old/大数据相关分享/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E5%88%86%E4%BA%AB/","excerpt":"开头语工欲善其事，必先利其器","text":"开头语工欲善其事，必先利其器 本次分享,是我在公司的第一次分享,我考虑后,将本次分享的主要内容分为了三大部块.先是针对相关基础组件分类介绍.再介绍下通过对这些组件进行组织配搭的大数据基础环境架构.再结合我的一些经历,为大家介绍下相关的应用与产品落地. 技术栈简介 数据采集 数据存储 数据治理(清洗&amp;处理) 数据应用 产品落地 我又根据不同组件的特性将他们分 采集类 存储类 计算处理类 传输类 管理类 其它类 下面开始具体介绍 采集类数据源: 日志 业务数据 公网数据(爬虫) 文本数据 出行数据(gps,手机定位等) sqoop flume crawler datax kettle elk Flume(水槽) 是 Cloudera 提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统。Flume基于流式架构，灵活简单,可拓展 Sqoop是一个在结构化数据和Hadoop之间进行批量数据迁移的工具，结构化数据可以是Mysql、Oracle等RDBMS。Sqoop底层用MapReduce程序实现抽取、转换、加载，MapReduce天生的特性保证了并行化和高容错率，而且相比Kettle等传统ETL工具，任务跑在Hadoop集群上，减少了ETL服务器资源的使用情况。在特定场景下，抽取过程会有很大的性能提升。 crawler , jsoup ,httpclient, nutch 等. elk 集中式日志系统 ELK 协议栈详解 存储类 hdfs hbase hive mongdb redis RDBMS hdfs* 分布式文件存储系统 * 提供了高可靠性、高扩展性和高吞吐率的数据存储服务 * hdfs典型结构：物理结构+逻辑结构 * 文件线性切割成Block：偏移量（offset） * Block分散存储在集群节点中 * 单一文件Block大小一致，文件与文件可以不一致 * Block可以设置副本数，副本分散在不同的节点中 * 副本数不要超过节点数量 * 文件上传可以设置Block大小和副本数 * 已上传的文件Block副本数可以调整，大小不变 * 只支持一次写入多次读取，同一时刻只有一个写入者 * 只能追加，不能修改 hbaseBase是一个构建在HDFS上的分布式列存储系统；Base是基于Google BigTable模型开发的，典型的key/value系统；Base是Apache Hadoop生态系统中的重要一员，主要用于海量结构化数据存储； 大：一个表可以有数十亿行，上百万列；无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态的增加，同一张表中不同的行可以有截然不同的列；面向列：面向列（族）的存储和权限控制，列（族）独立检索；稀疏：空（null）列并不占用存储空间，表可以设计的非常稀疏；数据多版本：每个单元中的数据可以有多个版本，默认情况下版本号自动分配，是单元格插入时的时间戳；数据类型单一：Hbase中的数据都是字符串，没有类型 openTSDB基于Hbase的分布式的，可伸缩的时间序列数据库。主要用途，就是做监控系统；譬如收集大规模集群（包括网络设备、操作系统、应用程序）的监控数据并进行存储，查询。 solr &amp; Phoenix二级索引 hiveive 是一个基于 Hadoop 文件系统之上的数据仓库架构。它可以将结构化的数据文件映射为一张数据库表，并提供简单的 sql 查询功能。还可以将 sql 语句转换为 MapReduce 任务运行。底部计算引擎还可以用用Tez, spark等. ImpalaImpala是Cloudera公司推出，提供对HDFS、Hbase数据的高性能、低延迟的交互式SQL查询功能。 基于Hive使用内存计算，兼顾数据仓库、具有实时、批处理、多并发等优点 对内存依赖大,稳定性不如hive 相比hive数据仓库,impala针对的量级相关少些,但会有效率的提升.但一般来讲,数据仓库一类需求对时间上的要要求一般不会太高,所以常规方式一般就符合大多数需求. 计算处理类 mapreduce mapreduce on oozie ,on tez spark flink mapreduceMapreduce是一个计算框架，既然是做计算的框架，那么表现形式就是有个输入（input），mapreduce操作这个输（input），通过本身定义好的计算模型，得到一个输出（output），这个输出就是我们所需要的结果。我们要学习的就是这个计算模型的运行规则。在运行一个mapreduce计算任务时候，任务过程被分为两个阶段：map阶段和reduce阶段，每个阶段都是用键值对（key/value）作为输入（input）和输出（output）。而程序员要做的就是定义好这两个阶段的函数：map函数和reduce函数。 分布式计算；移动计算而不移动数据。 spark相比一二代计算引擎,在兼并了一二代的特色之外,还引放了流计算这一能力,还丰富了计算函数.其中比较有代表性的主要就是spark&amp;storm.也就是说这代计算引擎兼具无边界数据与有边界数据同样的处理能力.同时还具有DAG特性.这里主要介绍spark spark主要组成有以下 spark-core spark-streaming spark-sql spark-mlib spark-graphX。 spark-core是一个提供内存计算的框架,其他的四大框架都是基于spark core上进行计算的,所以没有spark core,其他的框架是浮云.spark-core的主要内容就是对RDD的操作RDD的创建 -&gt;RDD的转换 -&gt;RDD的缓存 -&gt;RDD的行动 -&gt;RDD的输出 spark-streaming中使用离散化流（discretized stream）作为抽象的表示，叫做DStream。它是随时间推移而收集数据的序列，每个时间段收集到的数据在DStream内部以一个RDD的形式存在。DStream支持从kafka，flume,hdfs,s3等获取输入。DStream也支持两种操作，即转化操作和输出操作 spark-sqlSpark SQL 提供了查询结构化数据及计算结果等信息的接口.查询结果以 Datasets and DataFrames 形式返回 … flink/blink略 传输类kafkaKafka是分布式发布-订阅消息系统,一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。日常中常与spark-streaming结合实用,为其提供无边界数据 管理类 Hue cloudera-managerue与cm 都是由cloudera提供,后面cloudera将hue开源给了apache.如果基础集群环境是采用的是开源自主搭建,可考虑引入hue.另一些大数据服务公司,有集成打包自己的一些大数据产品,如cdh等.但这些服务收费,涉及到成本问题.所以如何选用,需要相关斟酌. 其它类 zookeeper ,yarn等zookeeper在集中基础环境中主要作为配置分享中心,与kafka,hbase等组件集成.yarn则作为资源管理组件,可以与mapreduce ,spark等集成 各类组件架构以上,已经大致介绍了各类工具,基本了解了相应的特性和使用场景,而根据它们的特性,进行合理的配备,架构,从而实现一个功能全面,稳定的大数据环境. 于我个人经历与平时了解来讲,一般的架构主要如下另: 总得来说,各类组件供选型一般来讲都不是单一的.所以,我们的大数据环境各部份组件都是插销式可插拔的.所以不同公司可能不一而同,具体看自身需求和实际情况.比如上图中的storm流式计算模块,就可以替换成spark-streaming等. 通过对上图的架构的拆解,再组合,可能还会有以下组织架构. 数据仓库可以理解为上图中间部份.作为一个数据集市的存在,算作数据中心的一部份. ODS：是数据仓库第一层数据，直接从原始数据过来的，经过简单地处理，比喻：字段体重的数据为175cm等数据。 DW*：这个是数据仓库的第二层数据，DWD和DWS很多情况下是并列存在的，这一层储存经过处理后的标准数据，比喻订单、用户、页面点击流量等数据。 ADS：这个是数据仓库的最后一层数据，为应用层数据，直接可以给业务人员使用。 星型模型 星型模型中有两个重要的概念：事实表和维度表。事实表：一些主键ID的集合，没有存放任何实际的内容维度表：存放详细的数据信息，有唯一的主键ID。如上面的关键词表、用户表等等。 数据中心:概念相对更大一些,可能即作为具体平台产品集合,也可能是一个团队行政划分.总得来说,是如 大数据基础平台 数据仓库 DMP平台 相关应用平台如推荐系统,报表系统,可视化平台等. 数据中台:这个是由阿里于15年率先提出.主导思想是大中台,小前台.这块暂无特别明确的解释说法,但现在也有不少公司效仿.我个人从它的主导思想”大中台,小前台”的理解是,这个可能是体量更大,壁垒更少的一个数据集成体.比如阿里系的旗下公司,数据流都会归集到中台,同时阿里系下的公司也能获得不仅自己公司数据中心归集的数据反馈,还能获得阿里中台整合后流出的反馈数据. 应用落地公共服务 交通出行 智慧城市 … 产品应用 用户画像 征信模型 推荐系统 精确营销 前沿科学(无人驾驶,人工智能,AR等) 结语以上,就是我今天分享的主要内容.今天的主题是”器”,但对这些工具的讲解浅尝辄止,在实际的开发实战中涉及的情况是更为复杂,需要掌握的内容更多,深度也更深.我这里主要是想抛砖引玉,为大家提供一点自己的理解,若能有所帮助,不胜荣幸. 另外,工具始终是工具,菜刀再利也要厨子好,才能做好菜.所以如何利用这些工具,与我们的业务结合,实现我们想要的价值,这是我一直在探索的,也愿与各位同仁一同前行. 附上图中涉及到的技术栈","categories":[],"tags":[{"name":"日常总结","slug":"日常总结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"}]},{"title":"spark常见的输入源","slug":"日常总结/spark/spark常见的输入源","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.162Z","comments":true,"path":"2020/05/11/日常总结/spark/spark常见的输入源/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/spark/spark%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BE%93%E5%85%A5%E6%BA%90/","excerpt":"spark 输入源整理","text":"spark 输入源整理 spark常见的输入源text1234567891011public static void main(String[] args) &#123; SparkConf conf = new SparkConf().setAppName(\"text_count\"); JavaSparkContext sc = new JavaSparkContext(conf); JavaRDD&lt;String&gt; tRDD = sc.textFile(\"/Users/kuiq.wang/Desktop/upload/yd_conver.txt\", 3); long res = tRDD.count(); log.info(\"text_count's result is [&#123;&#125;]\", res); &#125; collect123456789public static void main(String[] args) &#123; SparkConf conf &#x3D; new SparkConf().setAppName(&quot;collectRDD&quot;); JavaSparkContext jsc &#x3D; new JavaSparkContext(conf); JavaRDD collectRDD &#x3D; jsc.parallelize(Arrays.asList(new String[]&#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)); long res &#x3D; collectRDD.count(); log.info(&quot;collect rdd res is [&#123;&#125;]&quot;, res);&#125; elasticsearch准备 123456&lt;!--spark-es--&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;&#x2F;groupId&gt; &lt;artifactId&gt;elasticsearch-spark-20_2.11&lt;&#x2F;artifactId&gt; &lt;version&gt;6.7.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 12345678public static void readES(String url, String index) &#123; SparkConf conf = new SparkConf().setAppName(\"es_count\").set(\"es.nodes\", \"data1:9200\"); JavaSparkContext jsc = new JavaSparkContext(conf); JavaPairRDD&lt;String, Map&lt;String, Object&gt;&gt; esRDD = JavaEsSpark.esRDD(jsc, \"funnylog_test\"); long es = esRDD.count(); System.out.println(\"res is :\" + es);&#125; hbase12 kafka","categories":[],"tags":[]},{"title":"日常运维","slug":"日常总结/运维/日常运维","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-26T14:32:28.136Z","comments":true,"path":"2020/05/11/日常总结/运维/日常运维/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/11/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E8%BF%90%E7%BB%B4/%E6%97%A5%E5%B8%B8%E8%BF%90%E7%BB%B4/","excerpt":"此处是简介","text":"此处是简介 hexo 加速通过更换公共CDN的js css资源.实现了较大改变 hexo LocalSearch一直转圈问题修复主要成因有两,一是search.xml没有成功加载,二是search.xml中的数据有问题. 前者通过配置_config.yml文档和对应主题下的_config.yml配置 12345search: path: search.xml field: post format: html limit: 10000 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 同时记得关闭Algolia_Search 123# Algolia Searchalgolia_search: enable: false","categories":[],"tags":[{"name":"运维 cdn 加速","slug":"运维-cdn-加速","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E8%BF%90%E7%BB%B4-cdn-%E5%8A%A0%E9%80%9F/"}]},{"title":"准备小结","slug":"日常总结/old/准备小结","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-26T14:32:28.144Z","comments":true,"path":"2020/05/10/日常总结/old/准备小结/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/10/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/%E5%87%86%E5%A4%87%E5%B0%8F%E7%BB%93/","excerpt":"准备小结","text":"准备小结 hdfs存储机制是怎样的?client端发送写文件请求，namenode检查文件是否存在，如果已存在，直接返回错误信息，否则，发送给client一些可用namenode节点client将文件分块，并行存储到不同节点上datanode上，发送完成后，client同时发送信息给namenode和datanodenamenode收到的client信息后，发送确信信息给datanodedatanode同时收到namenode和datanode的确认信息后，提交写操作。 hadoop中combiner的作用是什么?当map生成的数据过大时，带宽就成了瓶颈，怎样精简压缩传给Reduce的数据，又不影响最终的结果呢。有一种方法就是使用Combiner，Combiner号称本地的Reduce，Reduce最终的输入，是Combiner的输出。 你们数据库怎么导入hive 的,有没有出现问题在导入hive的时候，如果数据库中有blob或者text字段，会报错，解决方案在sqoop笔记中。在将数据由Oracle数据库导入到Hive时，发现带有clob字段的表的数据会错乱，出现一些字段全为NULL的空行。由于在项目中CLOB字段没有实际的分析用途，因此考虑将CLOB字段去掉。 hdfs-site.xml的3个主要属性?dfs.name.dir决定的是元数据存储的路径以及DFS的存储方式(磁盘或是远端)dfs.data.dir决定的是数据存储的路径fs.checkpoint.dir用于第二Namenode 下列哪项通常是集群的最主要瓶颈磁盘 IO答案：C 磁盘首先集群的目的是为了节省成本，用廉价的 pc 机，取代小型机及大型机。小型机和大型机有什么特点？1.cpu 处理能力强2.内存够大，所以集群的瓶颈不可能是 a 和 d3.如果是互联网有瓶颈，可以让集群搭建内网。每次写入数据都要通过网络（集群是内网），然后还要写入 3 份数据，所以 IO 就会打折扣。 关于 SecondaryNameNode 哪项是正确的？它的目的是帮助 NameNode 合并编辑日志，减少 NameNode 启动时间 mapreduce的原理?MapReduce采用”分而治之”的思想，把对大规模数据集的操作，分发给一个主节点管理下的各个分节点共同完成，然后通过整合各个节点的中间结果，得到最终结果。简单地说，MapReduce就是”任务的分解与结果的汇总”。在Hadoop中，用于执行MapReduce任务的机器角色有两个：一个是JobTracker；另一个是TaskTracker，JobTracker是用于调度工作的，TaskTracker是用于执行工作的。一个Hadoop集群中只有一台JobTracker。在分布式计算中，MapReduce框架负责处理了并行编程中分布式存储、工作调度、负载均衡、容错均衡、容错处理以及网络通信等复杂问题，把处理过程高度抽象为两个函数：map和reduce，map负责把任务分解成多个任务，reduce负责把分解后多任务处理的结果汇总起来。需要注意的是，用MapReduce来处理的数据集（或任务）必须具备这样的特点：待处理的数据集可以分解成许多小的数据集，而且每一个小数据集都可以完全并行地进行处理。 HDFS存储的机制?写流程：client链接namenode存数据namenode记录一条数据位置信息（元数据），告诉client存哪。client用hdfs的api将数据块（默认是64M）存储到datanode上。datanode将数据水平备份。并且备份完将反馈client。client通知namenode存储块完毕。namenode将元数据同步到内存中。另一块循环上面的过程。 读流程举一个简单的例子说明mapreduce是怎么来运行的 ?MapReduce运行的时候，会通过Mapper运行的任务读取HDFS中的数据文件，然后调用自己的方法，处理数据，最后输出。 Reducer任务会接收Mapper任务输出的数据，作为自己的输入数据，调用自己的方法，最后输出到HDFS的文件中。Mapper任务的执行过程详解 每个Mapper任务是一个Java进程，它会读取HDFS中的文件，解析成很多的键值对，经过我们覆盖的map方法处理后，转换为很多的键值对再输出。整个Mapper任务的处理过程又可以分为以下六个阶段： 第一阶段是把输入文件按照一定的标准分片(InputSplit)，每个输入片的大小是固定的。默认情况下，输入片(InputSplit)的大小与数据块(Block)的大小是相同的。如果数据块(Block)的大小是默认值128MB，输入文件有两个，一个是32MB，一个是 172MB。那么小的文件是一个输入片，大文件会分为两个数据块，那么是两个输入片。一共产生三个输入片。每一个输入片由 一个Mapper进程处理。这里的三个输入片，会有三个Mapper进程处理。 第二阶段是对输入片中的记录按照一定的规则解析成键值对。有个默认规则是把每一行文本内容解析成键值对。“键”是每一 行的起始位置(单位是字节)，“值”是本行的文本内容。 第三阶段是调用Mapper类中的map方法。第二阶段中解析出来的每一个键值对，调用一次map方法。如果有1000个键值对，就会 调用1000次map方法。每一次调用map方法会输出零个或者多个键值对。 第四阶段是按照一定的规则对第三阶段输出的键值对进行分区。比较是基于键进行的。比如我们的键表示省份(如北京、上海、 山东等)，那么就可以按照不同省份进行分区，同一个省份的键值对划分到一个区中。默认是只有一个区。分区的数量就是Reducer 任务运行的数量。默认只有一个Reducer任务。第五阶段是对每个分区中的键值对进行排序。首先，按照键进行排序，对于键相同的键值对，按照值进行排序。比如三个键值 对&lt;2,2&gt;、&lt;1,3&gt;、&lt;2,1&gt;，键和值分别是整数。那么排序后的结果是&lt;1,3&gt;、&lt;2,1&gt;、&lt;2,2&gt;。如果有第六阶段，那么进入 第六阶段 如果没有，直接输出到本地的Linux文件中。 第六阶段是对数据进行归约处理，也就是reduce处理。键相等的键值对会调用一次reduce方法。经过这一阶段，数据量会减少。 归约后的数据输出到本地的linxu文件中。本阶段默认是没有的，需要用户自己增加这一阶段的代码。 Reducer任务的执行过程详解每个Reducer任务是一个java进程。Reducer任务接收Mapper任务的输出，归约处理后写入到HDFS中，可以分为三个阶段：第一阶段是Reducer任务会主动从Mapper任务复制其输出的键值对。Mapper任务可能会有很多，因此Reducer会复制多个Mapper的输出。第二阶段是把复制到Reducer本地数据，全部进行合并，即把分散的数据合并成一个大的数据。再对合并后的数据排序。第三阶段是对排序后的键值对调用reduce方法。键相等的键值对调用一次reduce方法，每次调用会产生零个或者多个键值对。最后把这些输出的键值对写入到HDFS文件中。在整个MapReduce程序的开发过程中，我们最大的工作量是覆盖map函数和覆盖reduce函数。 了解hashMap 和hashTable吗介绍下，他们有什么区别。为什么重写equals还要重写hashcode因为equals比较的是内容是一致.但hashcode 说一下map的分类和常见的情况 hashmap,hashtable,treemap,LinkedHashMap 根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复Hashmap是一个最常用的Map 它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的 最多只允许一条记录的键为Null;允许多条记录的值为 Null; HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。 如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMapHashtableHashtable与 HashMap类似,它继承自Dictionary类,不同的是:它不允许记录的键或者值为空; 它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢LinkedHashMap是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关TreeMap实现 SortMap 接口,能够把它保存的记录根据键排序, 默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的 HashMap，链表法存储，entry[]数组，线程不安全，可能死锁 concurrentHashMap，segment数组，每个segent下维护一组entry[]数组，每个segment是一把锁，线程安全 LinkedHashMap Object若不重写hashCode()的话，hashCode()如何计算出来的？hashcode采用的是 spark1. spark的有几种部署模式，每种模式特点？本地模式本地模式分三类 local：只启动一个executor local[k]: 启动k个executor local[*]：启动跟cpu数目相同的 executor cluster模式cluster模式肯定就是运行很多机器上了，但是它又分为以下三种模式，区别在于谁去管理资源调度。（说白了，就好像后勤管家，哪里需要资源，后勤管家要负责调度这些资源） standalone模式分布式部署集群，自带完整的服务，资源管理和任务监控是Spark自己监控，这个模式也是其他模式的基础 Spark on yarn模式分布式部署集群，资源和任务监控交给yarn管理粗粒度资源分配方式，包含cluster和client运行模式cluster 适合生产，driver运行在集群子节点，具有容错功能client 适合调试，dirver运行在客户端 2. Spark技术栈有哪些组件，每个组件都有什么功能，适合什么应用场景？Spark core是其它组件的基础，spark的内核主要包含：有向循环图、RDD、Lingage、Cache、broadcast等 SparkStreaming是一个对实时数据流进行高通量、容错处理的流式处理系统将流式计算分解成一系列短小的批处理作业 Spark sql：能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行外部查询 MLBase是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低MLBase分为四部分：MLlib、MLI、ML Optimizer和MLRuntime。 GraphX是Spark中用于图和图并行计算 spark有哪些组件master：管理集群和节点，不参与计算。worker：计算节点，进程本身不参与计算，和master汇报。Driver：运行程序的main方法，创建spark context对象。spark context：控制整个application的生命周期，包括dagsheduler和task scheduler等组件。client：用户提交程序的入口。 https://blog.csdn.net/yirenboy/article/details/47441465","categories":[],"tags":[{"name":"小结","slug":"小结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%B0%8F%E7%BB%93/"}]},{"title":"5.7","slug":"日常总结/最近/5.7","date":"2020-05-06T16:00:00.000Z","updated":"2020-05-26T14:32:28.165Z","comments":true,"path":"2020/05/07/日常总结/最近/5.7/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/05/07/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/%E6%9C%80%E8%BF%91/5.7/","excerpt":"","text":"Q: git 本地与远程分支建立联系","categories":[],"tags":[{"name":"spark es kafka","slug":"spark-es-kafka","permalink":"http://www.wqkenqing.ren/daydoc/tags/spark-es-kafka/"}]},{"title":"es常用命令","slug":"日常总结/es/es常用命令","date":"2020-02-24T16:00:00.000Z","updated":"2020-05-26T14:32:28.160Z","comments":true,"path":"2020/02/25/日常总结/es/es常用命令/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/02/25/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/es/es%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"此处是简介","text":"此处是简介 查看集群是否健康 1GET &#x2F;_cluster&#x2F;healt 查看节点列表 123GET &#x2F;_cat&#x2F;nodes?v加v将表头显示出来 索引查询所有索引1GET &#x2F;_cat&#x2F;indices?v 查看某个索引的映射1GET &#x2F;indeName&#x2F;mapping 查看某个索引的设置1GET &#x2F;indeName&#x2F;mapping 添加一个索引12345678910111213141516171819202122232425262728PUT &#x2F;indexName&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 3, &quot;number_of_replicas&quot;: 1 &#125;, &quot;mappings&quot;: &#123; &quot;man&quot;: &#123; &quot;dynamic&quot;: &quot;strict&quot;, &quot;properties&quot;: &#123; &quot;name&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;age&quot;: &#123; &quot;type&quot;: &quot;integer&quot; &#125;, &quot;birthday&quot;: &#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot; &#125;, &quot;address&quot;:&#123; &quot;dynamic&quot;: &quot;true&quot;, &quot;type&quot;: &quot;object&quot; &#125; &#125; &#125; &#125; &#125; dynamic关键词说明:“dynamic”:”strict” 表示如果遇到陌生field会报错“dynamic”: true 表示如果遇到陌生字段，就进行dynamic mapping“dynamic”: “false” 表示如果遇到陌生字段，就忽略 删除索引删除单个索引 12DELETE &#x2F;indexName 删除多个 12DELETE &#x2F;indexName1,indexName2 添加字段映射12345678PUT &#x2F;indexName&#x2F;_mapping&#x2F;Field&#123; &quot;properties&quot;:&#123; &quot;Field&quot;:&#123; &quot;type&quot;:&quot;text&quot; &#125; &#125;&#125; 索引的别名创建索引别名1PUT &#x2F;indeName&#x2F;_alias&#x2F;aliasName 获取索引别名 1GET &#x2F;indexName&#x2F;_alias&#x2F;* 查询别名对应的索引 1GET &#x2F;*&#x2F;_alias&#x2F;aliasName 文档向索引中添加文档 自定义ID 1234567PUT &#x2F;indexName&#x2F;type&#x2F;id&#123; &quot;Field1&quot;:&quot;message&quot;, &quot;Field2&quot;:&quot;message&quot;, &quot;Field3&quot;:&quot;message&quot;, &quot;Field4&quot;:&quot;message&quot;&#125; 随机生成id 1234567POST &#x2F;indexName&#x2F;type&#123; &quot;Field1&quot;:&quot;message&quot;, &quot;Field2&quot;:&quot;message&quot;, &quot;Field3&quot;:&quot;message&quot;, &quot;Field4&quot;:&quot;message&quot;&#125; 后者则会自动生成id字符串 修改文档 全文修改,即所有字段信息都要修改 1234567PUT &#x2F;indexName&#x2F;type&#x2F;id&#123; &quot;Field1&quot;:&quot;update message&quot;, &quot;Field2&quot;:&quot;update message&quot;, &quot;Field3&quot;:&quot;message&quot;, &quot;Field4&quot;:&quot;message&quot;&#125; 部份修改 123456POST &#x2F;indexName&#x2F;type&#x2F;id&#x2F;_update&#123; &quot;doc&quot;: &#123; &quot;FIELD&quot;: &quot;message&quot; &#125;&#125; 脚本(再深入) 12345678POST &#x2F;indexName&#x2F;type&#x2F;_id&#x2F;_update&#123; &quot;script&quot;: &#123; &quot;lang&quot;: &quot;painless&quot;, &quot;source&quot;: &quot;ctx._source.age +&#x3D; 10&quot; &#125;&#125; 在修改document的时候，如果该文档不存在，则使用upsert操作进行初始化 1234567POST people&#x2F;man&#x2F;1&#x2F;_update&#123; &quot;script&quot;: &quot;ctx._source.age +&#x3D; 10&quot;, &quot;upsert&quot;: &#123; &quot;age&quot;: 20 &#125;&#125; 删除文档删除单个文档 1DELETE &#x2F;indexName&#x2F;type&#x2F;id 删除type下所有的文档 12345678POST &#x2F;indexName&#x2F;type&#x2F;_delete_by_query?conflicts&#x3D;proceed&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123; &#125; &#125;&#125; 查询文档查询单个文档 1GET &#x2F;indexName&#x2F;type&#x2F;id 批量查询文档(待验证) 123456789101112131415GET &#x2F;_mget&#123; &quot;docs&quot;: [ &#123; &quot;_index&quot;: &quot;index1&quot;, &quot;_type&quot;: &quot;type&quot;, &quot;_id&quot;: 1 &#125;, &#123; &quot;_index&quot;: &quot;index2&quot;, &quot;_type&quot;: &quot;type&quot;, &quot;_id&quot;: 2 &#125; ]&#125; 123456789101112GET &#x2F;indexName&#x2F;type&#x2F;_mget&#123;&quot;docs&quot;:[&#123; &quot;FEILD&quot;:&quot;value&quot;&#125;,&#123; &quot;FEILD2&quot;:&quot;value&quot;&#125; ]&#125; 查询所有文档 简单查询 1GET &#x2F;indexName&#x2F;_serach 法二 1234567POST &#x2F;people&#x2F;_serach&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123; &#125; &#125;&#125; 查询某些字段内容 12345678910后面跟了 ?_source&#x3D;field1,field2POST &#x2F;people&#x2F;_serach?_source&#x3D;field1,field2&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123; &#125; &#125;&#125; 查询多个索引下的多个type 1GET &#x2F;index1,index2&#x2F;type1,type2&#x2F;_search 查询所有索引下的部分type 1GET &#x2F;_all&#x2F;type1,type2&#x2F;_search 模糊查询123456789101112131415POST &#x2F;indexName&#x2F;_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;field&quot;:&quot;message&quot; &#125; &#125; , &quot;sort&quot;:[ &#123; &quot;filed&quot;:&#123;&quot;order&quot;:&quot;desc&quot;&#125; &#125; ]&#125; 注意message将会被拆分进行匹配,若message是中文,则会按切分后的每个字来匹配,若message是英语,则会是按每个单词来匹配 全文搜索(按准度) 1234567891011GET indexName&#x2F;_search&#123; &quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;Field&quot;:&#123; &quot;query&quot;:&quot;val1 val2&quot;, &quot;operator&quot;:&quot;and&quot; &#125; &#125; &#125;&#125; 即Fileld 中必须有val1,val2 按匹配度查询 123456789101112GET &#x2F;indexName&#x2F;_search&#123;&quot;query&quot;:&#123; &quot;match&quot;:&#123; &quot;Field&quot;:&#123; &quot;query&quot;:&quot;val1 val2 val3&quot; &quot;minimum_should_match&quot;:&quot;val&quot; eg:20% &#125; &#125;&#125;&#125; 即indexName,按Field中 val1 val2 val3 匹配度达到val即返回查询 高级查询简单精准查询 12345678GET &#x2F;indexName&#x2F;_search&#123; &quot;query&quot;:&#123; &quot;match_phrase&quot;:&#123; &quot;Field&quot;:&quot;val&quot; &#125; &#125;&#125; 即查询要完全匹配val,但若val只有一个中文,则会Field只要含有val,就会被查出 slop结合 1234567891011GET &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;name&quot;: &#123; &quot;query&quot;: &quot;张三&quot;, &quot;slop&quot;: 3 &#125; &#125; &#125;&#125; 解读：slop是移动次数，上面案例表示“张”、“三”两个字可以经过最多挪动3次查询到！ rescore (重打分） 123456789101112131415161718192021GET &#x2F;forum&#x2F;article&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;java spark&quot; &#125; &#125;, &quot;rescore&quot;:&#123; &quot;window_size&quot;: 50, &quot;query&quot;: &#123; &quot;rescore_query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;content&quot;: &#123; &quot;query&quot;: &quot;java spark&quot;, &quot;slop&quot;: 50 &#125; &#125; &#125; &#125; &#125;&#125; 多字段匹配查询 123456789GET &#x2F;indexName&#x2F;_search&#123; &quot;query&quot;:&#123; &quot;multi_match&quot;:&#123; &quot;query&quot;:&quot;val&quot; &quot;fields&quot;:[&quot;val1&quot;,&quot;val2&quot;] &#125; &#125;&#125; 在多个字段中,也是模糊查询val 123456789GET &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;query_string&quot;: &#123; &quot;query&quot;: &quot;(叶良辰 AND 火) OR (赵日天 AND 风)&quot;, &quot;fields&quot;: [&quot;name&quot;,&quot;desc&quot;] &#125; &#125;&#125; 字段查询精准查询 12345678GET &#x2F;indexName&#x2F;_search&#123;&quot;query&quot;:&#123; &quot;term&quot;:&#123; &quot;field&quot;:&quot;val&quot; &#125;&#125;&#125; 分页查询 12345678GET &#x2F;indexName&#x2F;_search&#123; &quot;query&quot;:&#123; &quot;match_all&quot;:&#123;&#125; &#125;, &quot;from&quot;:num, &quot;size&quot;:num&#125; 范围查询数据值型 123456789101112GET &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gt&quot;: 16, &quot;lte&quot;: 30 &#125; &#125; &#125;&#125; 日期类型 1234567891011GET &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;range&quot;: &#123; &quot;birthday&quot;: &#123; &quot;gte&quot;: &quot;2013-01-01&quot;, &quot;lte&quot;: &quot;now&quot; &#125; &#125; &#125;&#125; 1234567891011121314151617GET book&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;constant_score&quot;: &#123; &quot;filter&quot;: &#123; &quot;range&quot;: &#123; &quot;date&quot;: &#123; &quot;gt&quot;: &quot;now-1M&quot; &#125; &#125; &#125;, &quot;boost&quot;: 1.2 &#125; &#125;&#125; “gt”: “now-1M”表示从今天开始，往前推一个月！ 过滤查询法一 123456789101112131415161718POST &#x2F;people&#x2F;man&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;constant_score&quot;: &#123; &quot;filter&quot;: &#123; &quot;range&quot;: &#123; &quot;age&quot;: &#123; &quot;gte&quot;: 20, &quot;lte&quot;: 30 &#125; &#125; &#125;, &quot;boost&quot;: 1.2 &#125; &#125;&#125; 法二 123456789101112POST &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;age&quot;: 18 &#125; &#125; &#125; &#125;&#125; 布尔查询should查询注意：should相当于 或 ，里面的match也是模糊匹配 12345678910111213141516171819POST &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;should&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;叶良辰&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;赵日天&quot; &#125; &#125; ] &#125; &#125;&#125; must查询注意：两个条件都要满足，并且这里也会把must里面的“叶良辰”拆分成“叶”、“良”和“辰”进行查询；“赵日天”拆分成“赵”、“日”、和“天”！ 1234567891011121314151617181920POST &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;叶良辰&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;赵日天&quot; &#125; &#125; ] &#125; &#125;&#125; must与filter相结合这里也会把must里面的“叶良辰”拆分成“叶”、“良”和“辰”进行查询 123456789101112131415161718192021222324252627POST &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: [ &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;叶良辰&quot; &#125; &#125;, &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;赵日天&quot; &#125; &#125; ], &quot;filter&quot;: [ &#123; &quot;term&quot;: &#123; &quot;age&quot;: 18 &#125; &#125; ] &#125; &#125;&#125; must_not注意：下面语句是精准匹配 123456789101112POST &#x2F;people&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must_not&quot;: &#123; &quot;term&quot;: &#123; &quot;name&quot;: &quot;叶良辰&quot; &#125; &#125; &#125; &#125;&#125; 聚合查询根据字段类型查询 123456789101112GET &#x2F;people&#x2F;man&#x2F;_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;group_by_age&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125; 查询总体值 12345678910POST &#x2F;people&#x2F;_search&#123; &quot;aggs&quot;: &#123; &quot;grads_age&quot;: &#123; &quot;stats&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125; 查询最小值 12345678910POST &#x2F;people&#x2F;_search&#123; &quot;aggs&quot;: &#123; &quot;grads_age&quot;: &#123; &quot;min&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125;&#125; 根据国家分组，然后计算年龄平均值： 12345678910111213141516171819GET &#x2F;people&#x2F;man&#x2F;_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;group_by_age&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;country&quot; &#125;, &quot;aggs&quot;: &#123; &quot;avg_age&quot;: &#123; &quot;avg&quot;: &#123; &quot;field&quot;: &quot;age&quot; &#125; &#125; &#125; &#125; &#125;&#125; 解决：上面的reason里面说的很清楚，将fielddata设置为true就行了： 12345678910POST &#x2F;people&#x2F;_mapping&#x2F;man&#123; &quot;properties&quot;: &#123; &quot;country&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fielddata&quot;: true &#125; &#125;&#125; 排序查询123456789101112131415161718192021222324252627282930313233343536373839排序查询通常没有排到我们想要的结果，因为字段分词后，有很多单词，再排序跟我们想要的结果又出入解决办法：把需要排序的字段建立两次索引，一个排序，另一个不排序。如下面的案例：把title.raw的fielddata设置为true，是排序的；而title的fielddata默认是false，可以用来搜索index: true 是在title.raw建立索引可以被搜索到，fielddata: true是让其可以排序PUT &#x2F;blog&#123; &quot;mappings&quot;: &#123; &quot;article&quot;: &#123; &quot;properties&quot;: &#123; &quot;auther&quot;: &#123; &quot;type&quot;: &quot;text&quot; &#125;, &quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;raw&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;index&quot;: true, &quot;fielddata&quot;: true &#125; &#125; &#125;, &quot;content&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;english&quot; &#125;, &quot;publishdate&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125; &#125; &#125; &#125;&#125; 12345678910111213GET &#x2F;blog&#x2F;article&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;title.raw&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125; ]&#125; scroll查询12345当搜索量比较大的时候，我们在短时间内不可能一次性搜索完然后展示出来这个时候，可以使用scroll进行搜索比如下面的案例，可以先搜索3条数据，然后结果中会有一个_scroll_id，下次搜索就可以直接用这个_scroll_id进行搜索了 12345678GET test_index&#x2F;test_type&#x2F;_search?scroll&#x3D;1m&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: &quot;_doc&quot;, &quot;size&quot;: 3&#125; step3 把scroll_id粘贴到下面的命令中再次搜索 12345GET _search&#x2F;scroll&#123; &quot;scroll&quot;: &quot;1m&quot;, &quot;scroll_id&quot;: &quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAA6FnZPSl9sbVR4UVVDU1NLb2wxVXJlbWcAAAAAAAAAPhZ2T0pfbG1UeFFVQ1NTS29sMVVyZW1nAAAAAAAAADsWdk9KX2xtVHhRVUNTU0tvbDFVcmVtZwAAAAAAAAA8FnZPSl9sbVR4UVVDU1NLb2wxVXJlbWcAAAAAAAAAPRZ2T0pfbG1UeFFVQ1NTS29sMVVyZW1n&quot;&#125; 运维reindex123456789POST _reindex&#123; &quot;source&quot;: &#123; &quot;index&quot;: &quot;activity_mini2&quot; &#125;, &quot;dest&quot;: &#123; &quot;index&quot;: &quot;activity_mini3&quot; &#125;&#125; 别名12345678910111213141516POST _aliases&#123; &quot;actions&quot;: [ &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;activity_mini2&quot;, &quot;alias&quot;: &quot;activity_mini2_alias&quot; &#125;&#125;, &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;activity_mini3&quot;, &quot;alias&quot;: &quot;activity_mini2_alias&quot; &#125; &#125; ]&#125; 快照同步这里先简单介绍以elasticsearch-dump为基础的同步 全量同步123elastcisearchdump --input&#x3D;path \\ --output&#x3D;path \\ --type&#x3D; 1上面常见的type有settings,mapping,data,alias等主要内容 DSL 语句同步12345elasticdump \\ --input&#x3D;http:&#x2F;&#x2F;path1:9200&#x2F;$1 \\ --output&#x3D;http:&#x2F;&#x2F;path2:9200&#x2F;$1 \\ --type&#x3D;data \\ --searchBody&#x3D;&quot;$body&quot; 因为走的是网络IO所以效率上会有较大问题.适用于小批量数据同步,后续再补充较大规模数据的迁移 拓展QAQ: 同一个字段如何通过不同的域(feild)实现多种类型的功能A: 如一个字段被定义成了text,但同时这个字段的内容也需要keyword的不分词的特性.那些通过配置fields 可实现该功能. 12345678&quot;title&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; 如上查询DSL配成 title.keyword时,则不可分词,查询出来的内容是唯一结果. 如果查询DSL配成titile时.则会分词","categories":[],"tags":[]},{"title":"ELK使用","slug":"日常总结/es/ELK/ELK","date":"2020-02-24T16:00:00.000Z","updated":"2020-05-26T14:32:28.160Z","comments":true,"path":"2020/02/25/日常总结/es/ELK/ELK/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/02/25/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/es/ELK/ELK/","excerpt":"针对ELK使用","text":"针对ELK使用 ELK 使用Elasticsearchelasticsearch之前已经另开篇章记录,这里略过 Logstash1一款轻量级的日志搜索处理框架,可以把分散,多样化的日志搜集起来,并通过配置发送到指定的位置","categories":[],"tags":[]},{"title":"Beats","slug":"日常总结/es/ELK/Beats","date":"2020-02-24T16:00:00.000Z","updated":"2020-05-26T14:32:28.159Z","comments":true,"path":"2020/02/25/日常总结/es/ELK/Beats/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2020/02/25/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/es/ELK/Beats/","excerpt":"1本文拟用的beats版本是6.7","text":"1本文拟用的beats版本是6.7 Beats1beats 是一款开源的轻量级采集组件,用于采集流转的数据. 常见的beats类型有 Auditbeat Filebeat Functionbeat Heartbeat Journalbeat Metricbeat Packetbeat Winlogbeat beats 能直接将数据采集发送到Logstash 或elasticsearch AuditbeatFilebeat","categories":[],"tags":[]},{"title":"hive2总结","slug":"日常总结/old/hive2总结","date":"2019-12-24T15:07:45.000Z","updated":"2020-05-26T14:32:28.145Z","comments":true,"path":"2019/12/24/日常总结/old/hive2总结/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/12/24/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/hive2%E6%80%BB%E7%BB%93/","excerpt":"Hive相关点小结","text":"Hive相关点小结 启动指令 hive == hive –service cli不需要启动server，使用本地的metastore，可以直接做一些简单的数据操作和测试。 启动hiveserver2hive –service hiveserver2 beeline工具测试使用jdbc方式连接beeline -u jdbc:hive2://localhost:10000 1.managed table管理表。删除表时，数据也删除了 2.external table外部表。删除表时，数据不删 建表:CREATE TABLE IF NOT EXISTS t2(id int,name string,age int)COMMENT ‘xx’ //注释ROW FORMAT DELIMITED //行分隔符FIELDS TERMINATED BY ‘,’ //字段分隔符，这里使用的是逗号可以根据自己的需要自行进行修改STORED AS TEXTFILE ; 外部表: CREATE TABLE IF NOT EXISTS t2(id int,name string,age int) COMMENT ‘xx’ ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘,’ STORED AS TEXTFILE ; 分区表，桶表分区表Hive中有分区表的概念。我们可以看到分区表具有重要的性能，而且分区表还可以将数据以一种符合逻辑的方式进行组织，比如分层存储。Hive的分区表，是把数据放在满足条件的分区目录下CREATE TABLE t3(id int,name string,age int) PARTITIONED BY (Year INT, Month INT) //按照年月进行分区 ROW FORMAT DELIMITED //行分隔符 FIELDS TERMINATED BY ‘,’ ; //字段分隔符，这里使用的是逗号可以根据自己的需要自行进行修改load data local inpath ‘/home/zpx/customers.txt’ into table t3 partition 分桶表这样做，在查找数据的时候就可以跨越多个桶，直接查找复合条件的数据了。速度快，时间成本低。Hive中的桶表默认使用的机制也是hash。CREATE TABLE t4(id int,name string,age int) CLUSTERED BY (id) INTO 3 BUCKETS //创建3个通桶表，按照字段id进行分桶 ROW FORMAT DELIMITED //行分隔符 FIELDS TERMINATED BY &apos;,&apos; ; load data local inpath ‘/home/centos/customers.txt’ into table t4 ; 导入数据load data local inpath ‘/home/zpx/customers.txt’ into table t2 ; //local上传文件load data inpath ‘/user/zpx/customers.txt’ [overwrite] into table t2 //分布式文件系统上移动文件 建视图Hive也可以建立视图，是一张虚表，方便我们进行操作. create view v1 as select a.id aid,a.name ,b.id bid , b.order from customers a left outer join default.tt b on a.id = b.cid ; Hive的严格模式Hive提供了一个严格模式，可以防止用户执行那些产生意想不到的不好的影响的查询。使用了严格模式之后主要对以下3种不良操作进行控制： 1.分区表必须指定分区进行查询。2.order by时必须使用limit子句。3.不允许笛卡尔积。 Hive的动态分区像分区表里面存储了数据。我们在进行存储数据的时候，都是明确的指定了分区。在这个过程中Hive也提供了一种比较任性化的操作，就是动态分区，不需要我们指定分区目录，Hive能够把数据进行动态的分发,我们需要将当前的严格模式设置成非严格模式，否则不允许使用动态分区set hive.exec.dynamic.partition.mode=nonstrict//设置非严格模式 Hive的排序Hive也提供了一些排序的语法，包括order by,sort by。 order by=MapReduce的全排序sort by=MapReduce的部分排序distribute by=MapReduce的分区 selece …….from …… order by 字段；//按照这个字段全排序 selece …….from …… sort by 字段； //按照这个字段局部有序 selece 字段…..from …… distribute by 字段；//按照这个字段分区特别注意的是： 在上面的最后一个distribute by使用过程中，按照排序的字段要出现在最左侧也就是select中有这个字段，因为我们要告诉MapReduce你要按照哪一个字段分区，当然获取的数据中要出现这个字段了。类似于我们使用group by的用法，字段也必须出现在最左侧，因为数据要包含这个字段，才能按照这个字段分组，至于Hive什么时候会自行的开启MapReduce，那就是在使用聚合的情况下开启，使用select …from ….以及使用分区表的selece ….from……where …..不会开启 distribute by与sort by可以组合使用，但是distribute by要放在前边，因为MapReduce要先分区，后排序，再归并 select 字段a,……..from …….distribute by字段a，sort by字段如果distribute by与sort by使用的字段一样，则可以使用cluster by 字段替代：select 字段a,……..from …….cluster by 字段 函数 show functions; 展示相关函数 desc function split; desc function extended split; //查看函数的扩展信息 用户自定义函数（UDF）具体步骤如下： （1）.自定义类（继承UDF，或是GenericUDF。GenericUDF是更为复杂的抽象概念，但是其支持更好的null值处理同时还可以处理一些标准的UDF无法支持的编程操作）。（2）.导出jar包，通过命令添加到hive的类路径。$hive&gt;add jar xxx.jar（3）.注册函数$hive&gt;CREATE TEMPORARY FUNCTION 函数名 AS ‘具体类路径：包.类’;（4）.使用 $hive&gt;select 函数名(参数);自定义实现类如下(继承UDF)：","categories":[],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"http://www.wqkenqing.ren/daydoc/tags/bigdata/"}]},{"title":"flink学习","slug":"日常总结/flink/Flink","date":"2019-07-30T16:00:00.000Z","updated":"2020-05-26T14:32:28.138Z","comments":true,"path":"2019/07/31/日常总结/flink/Flink/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/07/31/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/flink/Flink/","excerpt":"flink内容记录","text":"flink内容记录 搭建创建maven项目123456789mvn archetype:generate \\ -DarchetypeGroupId&#x3D;org.apache.flink \\ -DarchetypeArtifactId&#x3D;flink-quickstart-java \\ -DarchetypeVersion&#x3D;1.6.1 \\ -DgroupId&#x3D;my-flink-project \\ -DartifactId&#x3D;my-flink-project \\ -Dversion&#x3D;0.1 \\ -Dpackage&#x3D;myflink \\ -DinteractiveMode&#x3D;false 12mvn clean package -Dmaven.test.skip&#x3D;true 1flink run -c myflink.demo.SocketTextStreamWordCount my-flink-project-0.1.jar 127.0.0.1 9000 DataStream APIflink程序工作解剖图 执行环境flink支持 获取已经存在的flink环境 创建一个本地环境 创建一个远程环境 DataSource预置sourceSocket-based socketTextStream(); File-based Transfomations map flatMap filter keyBy reduce fold 合计 min max sum 窗口","categories":[],"tags":[{"name":"flink","slug":"flink","permalink":"http://www.wqkenqing.ren/daydoc/tags/flink/"}]},{"title":"hdfs命令","slug":"日常总结/hadoop/hdfs/hdfs命令","date":"2019-07-16T16:00:00.000Z","updated":"2020-05-26T14:32:28.156Z","comments":true,"path":"2019/07/17/日常总结/hadoop/hdfs/hdfs命令/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/07/17/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/hadoop/hdfs/hdfs%E5%91%BD%E4%BB%A4/","excerpt":"hdfs常用命令","text":"hdfs常用命令 count 1该命令选项显示指定路径下的文件夹数量、文件数量、文件总大小信息，如图4-6所示。 du 1统计目录下各文件大小 touchz 1创建空白文件 -stat 1“%b %n %o %r %Y”依次表示文件大小、文件名称、块大小、副本数、访问时间。","categories":[],"tags":[{"name":"hdfs","slug":"hdfs","permalink":"http://www.wqkenqing.ren/daydoc/tags/hdfs/"}]},{"title":"kafka小结","slug":"日常总结/oldblog/blog17","date":"2019-07-15T16:00:00.000Z","updated":"2020-05-26T14:32:28.139Z","comments":true,"path":"2019/07/16/日常总结/oldblog/blog17/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/07/16/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/oldblog/blog17/","excerpt":"此处简介","text":"此处简介 kafka小结消息系统术语kafka特性 分布式的 可分区的 可复制的 在普通的消息系统的功上，还有自己独特的设计 Kafka将消息以topic为单位进行归纳。将向Kafka topic发布消息的程序成为producers.将预订topics并消费消息的程序成为consumer.Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker.producers通过网络将消息发送到Kafka集群，集群向消费者提供消息， 客户端和服务端通过TCP协议通信。Kafka提供了Java客户端，并且对多种语言都提供了支持。 Topics 和Logs 先来看一下Kafka提供的一个抽象概念:topic.一个topic是对一组消息的归纳。对每个topic，Kafka 对它的日志进行了分区 一个topic是对一组消息的归纳。对每个topic，Kafka 对它的日志进行了分区， 每个分区都由一系列有序的、不可变的消息组成，这些消息被连续的追加到分区中。分区中的每个消息都有一个连续的序列号叫做offset,用来在分区中唯一的标识这个消息。 kafka常用指令收集查看topic的详细信息kafka-topics.sh -zookeeper 127.0.0.1:2181 -describe -topic topic name 为topic增加副本kafka-reassign-partitions.sh -zookeeper 127.0.0.1:2181 -reassignment-json-file json/partitions-to-move.json -execute创建topickafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic name为topic增加partitionkafka-topics.sh –zookeeper 127.0.0.1:2181 –alter –partitions 20 –topic namekafka生产者客户端命令kafka-console-producer.sh –broker-list localhost:9092 –topic namekafka消费者客户端命令kafka-console-consumer.sh -zookeeper localhost:2181 –from-beginning –topic namekafka服务启动kafka-server-start.sh -daemon ../config/server.properties删除topickafka-run-class.sh kafka.admin.DeleteTopicCommand –topic testKJ1 –zookeeper 127.0.0.1:2181kafka-topics.sh –zookeeper localhost:2181 –delete –topic testKJ1查看consumer组内消费的offsetkafka-run-class.sh kafka.tools.ConsumerOffsetChecker –zookeeper localhost:2181 –group test –topic name","categories":[],"tags":[]},{"title":"sparkstreaming 窗口操作","slug":"日常总结/spark/stream2","date":"2019-07-15T16:00:00.000Z","updated":"2020-05-26T14:32:28.164Z","comments":true,"path":"2019/07/16/日常总结/spark/stream2/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/07/16/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/spark/stream2/","excerpt":"sparkstreaming时间窗口设置","text":"sparkstreaming时间窗口设置 说明通过sparkstreaming设置窗口函数,可达到如,每10秒计算前30秒内数据的效果 如上 主要有两个参数 窗口大小 滑动距离 val windowedWordCounts = pairs.reduceByKeyAndWindow(_ + _, Seconds(30), Seconds(10)) 如上 常用api Transformation Meaning window(windowLength, slideInterval) Return a new DStream which is computed based on windowed batches of the source DStream. countByWindow(windowLength,slideInterval) Return a sliding window count of elements in the stream. reduceByWindow(func, windowLength,slideInterval) reduceByKeyAndWindow(func,windowLength, slideInterval, [numTasks]) reduceByKeyAndWindow(func, invFunc,windowLength, slideInterval, [numTasks]) countByValueAndWindow(windowLength,slideInterval, [numTasks])","categories":[],"tags":[{"name":"sparkstreaming","slug":"sparkstreaming","permalink":"http://www.wqkenqing.ren/daydoc/tags/sparkstreaming/"}]},{"title":"宽窄依赖","slug":"日常总结/spark/宽窄依赖","date":"2019-07-15T16:00:00.000Z","updated":"2020-05-26T14:32:28.163Z","comments":true,"path":"2019/07/16/日常总结/spark/宽窄依赖/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/07/16/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/spark/%E5%AE%BD%E7%AA%84%E4%BE%9D%E8%B5%96/","excerpt":"spark依赖说明","text":"spark依赖说明 种类spark的依赖关系大致有两类 narrow dependency wide dependency 说明narrow dependency父Partition ===&gt; 子partition 多对一或一对一 flatMap ,mapToPair ,map ,filter等算子父partition ===&gt; 子partition 一对多 reduce ,group by 等. stage当一个dag串联遇到宽依赖时形成stage.一个stage对应一个task.这个task的并行度由最后一个依赖决定.应该就是说由wide dependency 的具体并行度决度.如reduce ,partition=3.就3的并行度.这里的参数可以设置. wide dependency 必定对应的有shuffle.但shuffle不一定是wide dependency 如sort orderby join 即可能发生shuffle也可能不,具体看情况. pipeline一个stage划分好后.一条数据的具体运算逻辑是会一直走完所有计算逻辑后才会落地.这是与mapreduce的区别mapreduce是计算逻辑走完落地,再启动,计算又落地. 所以说spark的效率比mapreduce高也是有这个原因.dag串联后,运算优先.","categories":[],"tags":[{"name":"spark dependency","slug":"spark-dependency","permalink":"http://www.wqkenqing.ren/daydoc/tags/spark-dependency/"}]},{"title":"updateStateByKey&mapStateWithKey","slug":"日常总结/spark/stream","date":"2019-07-14T16:00:00.000Z","updated":"2020-05-26T14:32:28.163Z","comments":true,"path":"2019/07/15/日常总结/spark/stream/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/07/15/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/spark/stream/","excerpt":"spark中如何实现全局count","text":"spark中如何实现全局count 说明两种方式都可以实现对同一key的累计统计 区别updateStateByKey会返回无增量数据的状态,所以会相对较大的数据资源开销mapStateWithKey 相当于增量统计 使用updateStateByKey : 12345678910111213141516public static Function2&lt;List&lt;Integer&gt;, Optional&lt;Integer&gt;, Optional&lt;Integer&gt;&gt; updateFunctionByUpdate() &#123; Function2&lt;List&lt;Integer&gt;, Optional&lt;Integer&gt;, Optional&lt;Integer&gt;&gt; updateFunction = (values, s1) -&gt; &#123; Integer newSum = 0; if (s1.isPresent()) &#123; newSum = s1.get(); &#125; Iterator&lt;Integer&gt; i = values.iterator(); while (i.hasNext()) &#123; newSum += i.next(); &#125; return Optional.of(newSum); &#125;; return updateFunction; &#125; mapStateWithKey : 12345678910public static Function3&lt;String, Optional&lt;Integer&gt;, State&lt;Integer&gt;, Tuple2&lt;String, Integer&gt;&gt; updateFunctionByMap() &#123; Function3&lt;String, Optional&lt;Integer&gt;, State&lt;Integer&gt;, Tuple2&lt;String, Integer&gt;&gt; updateFunction2 = (word, one, state) -&gt; &#123; int sum = one.or(0) + (state.exists() ? state.get() : 0); Tuple2&lt;String, Integer&gt; output = new Tuple2&lt;String, Integer&gt;(word, sum); state.update(sum); return output; &#125;; return updateFunction2; &#125;","categories":[],"tags":[{"name":"sparkstream","slug":"sparkstream","permalink":"http://www.wqkenqing.ren/daydoc/tags/sparkstream/"}]},{"title":"Yarn配置细节","slug":"日常总结/old/Yarn配置","date":"2019-06-12T16:00:00.000Z","updated":"2020-05-26T14:32:28.147Z","comments":true,"path":"2019/06/13/日常总结/old/Yarn配置/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/06/13/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/Yarn%E9%85%8D%E7%BD%AE/","excerpt":"此处简介","text":"此处简介 Yarn配置细节##内存,核数设置 1234567891011121314151617181920212223242526272829303132 &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;&#x2F;name&gt; &lt;value&gt;4096&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;&#x2F;name&gt; &lt;value&gt;1024&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;&#x2F;name&gt; &lt;value&gt;3072&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;!--该配置用于配置任务请求时的资源. --&gt;&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.resource.mb&lt;&#x2F;name&gt; &lt;value&gt;2048&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.command-opts&lt;&#x2F;name&gt; &lt;value&gt;-Xmx3276m&lt;&#x2F;value&gt;&lt;&#x2F;property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;&#x2F;name&gt; &lt;value&gt;2&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;&lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;&#x2F;name&gt; &lt;value&gt;3&lt;&#x2F;value&gt;&lt;&#x2F;property&gt;","categories":[],"tags":[]},{"title":"flume记录","slug":"日常总结/old/flume记录","date":"2019-06-12T16:00:00.000Z","updated":"2020-05-26T14:32:28.143Z","comments":true,"path":"2019/06/13/日常总结/old/flume记录/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/06/13/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/flume%E8%AE%B0%E5%BD%95/","excerpt":"此处简介","text":"此处简介 flume记录from kafka 123456789101112131415161718192021222324252627282930313233343536373839a1.sources &#x3D; source1a1.sources.source1.type &#x3D; org.apache.flume.source.kafka.KafkaSourcea1.sources.source1.channels &#x3D; c1a1.sources.source1.batchSize &#x3D; 5000a1.sources.source1.batchDurationMillis &#x3D; 2000a1.sources.source1.zookeeperConnect &#x3D; localhost:2181#a1.sources.source1.kafka.brokerList &#x3D; localhost:9092a1.sources.source1.kafka.bootstrap.servers &#x3D; localhost:9092a1.sources.source1.topic &#x3D; flumetesta1.sources.source1.kafka.consumer.group.id &#x3D; custom.g.ida1.channels &#x3D; c1a1.channels.c1.type &#x3D; memorya1.channels.c1.capacity &#x3D; 10000a1.channels.c1.transactionCapacity &#x3D; 10000a1.channels.c1.byteCapacityBufferPercentage &#x3D; 20a1.channels.c1.byteCapacity &#x3D; 800000a1.sinks &#x3D; k1a1.sinks.k1.type &#x3D; file_rolla1.sinks.k1.channel &#x3D; c1a1.sinks.k1.sink.directory &#x3D; &#x2F;home&#x2F;hadoop&#x2F;testfile&#x2F;flume 这里也有版本匹配的问题.经过多番尝试,这里的组合版本是flume1.6+kafka_2.11-2.2.0.tgz其它版本可能会有request header 问题.另外还遇到了指定topic 和 zookeeper的问题. 执行语句:flume-ng agent -n a1 -c conf -f kafka.properties -Dflume.root.logger=INFO,console flume 采集到kafka123456789101112131415161718192021222324252627agent.sources&#x3D;r1agent.sinks&#x3D;k1agent.channels&#x3D;c1agent.sources.r1.type&#x3D;execagent.sources.r1.command&#x3D;tail &#x2F;root&#x2F;tomcat&#x2F;logs&#x2F;catalina.outagent.sources.r1.restart&#x3D;trueagent.sources.r1.batchSize&#x3D;1000agent.sources.r1.batchTimeout&#x3D;3000agent.sources.r1.channels&#x3D;c1agent.channels.c1.type&#x3D;memoryagent.channels.c1.capacity&#x3D;102400agent.channels.c1.transactionCapacity&#x3D;1000agent.channels.c1.byteCapacity&#x3D;134217728agent.channels.c1.byteCapacityBufferPercentage&#x3D;80agent.sinks.k1.channel&#x3D;c1agent.sinks.k1.type&#x3D;org.apache.flume.sink.kafka.KafkaSinkagent.sinks.k1.kafka.topic&#x3D;sparkstreamingagent.sinks.k1.kafka.zookeeperConnect&#x3D;47.102.199.215:2181#agent.sinks.k1.kafka.bootstrap.servers&#x3D;47.102.199.215:9092agent.sinks.k1.kafka.brokerList &#x3D;47.102.199.215:9092agent.sinks.k1.serializer.class&#x3D;kafka.serializer.StringEncoderagent.sinks.k1.flumeBatchSize&#x3D;1000agent.sinks.k1.useFlumeEventFormat&#x3D;true","categories":[],"tags":[]},{"title":"SparkSql","slug":"日常总结/spark/sql/SparkSql","date":"2019-06-12T16:00:00.000Z","updated":"2020-05-26T14:32:28.165Z","comments":true,"path":"2019/06/13/日常总结/spark/sql/SparkSql/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/06/13/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/spark/sql/SparkSql/","excerpt":"1spark sql 相关内容","text":"1spark sql 相关内容 sparksql","categories":[],"tags":[]},{"title":"CDH搭建细节","slug":"日常总结/CDH/搭建","date":"2019-05-26T16:00:00.000Z","updated":"2020-05-26T14:32:28.153Z","comments":true,"path":"2019/05/27/日常总结/CDH/搭建/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/05/27/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/CDH/%E6%90%AD%E5%BB%BA/","excerpt":"…..","text":"….. CDH安装准备 ubuntu ulimit","categories":[],"tags":[]},{"title":"spark操作.md","slug":"日常总结/spark/spark操作","date":"2019-05-16T16:00:00.000Z","updated":"2020-05-26T14:32:28.162Z","comments":true,"path":"2019/05/17/日常总结/spark/spark操作/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/05/17/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/spark/spark%E6%93%8D%E4%BD%9C/","excerpt":"spark编程积累","text":"spark编程积累 spark编程Inputhdfs操作hdfs比较常规,直接通过context.textfile(path) //即可实现 hbasehbase 则要通过newAPIHadoopRDD来实现 12JavaPairRDD&lt;ImmutableBytesWritable, Result&gt; javaRDD = jsc.newAPIHadoopRDD(HbaseOperate.getConf(), TableInputFormat.class, ImmutableBytesWritable.class, Result.class); 这里要特别说明的是,这里的conf承担了更多的责任,如指定表名,指定scan传输字符串等. 12345Configuration hconf = HbaseOperate.getConf(); Scan scan = new Scan(); hconf.set(TableInputFormat.INPUT_TABLE, \"company\"); hconf.set(TableInputFormat.SCAN, convertScanToString(scan)); 参考以上这段代码 另 1234static String convertScanToString(Scan scan) throws IOException &#123; ClientProtos.Scan proto = ProtobufUtil.toScan(scan); return Base64.encodeBytes(proto.toByteArray()); &#125; 以上是为实现scan指令传输字符的封装. 两者底层都是通过persist实现","categories":[],"tags":[]},{"title":"hbaes操作","slug":"日常总结/hadoop/hbase/hbase操作","date":"2019-05-16T16:00:00.000Z","updated":"2020-05-26T14:32:28.157Z","comments":true,"path":"2019/05/17/日常总结/hadoop/hbase/hbase操作/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/05/17/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/hadoop/hbase/hbase%E6%93%8D%E4%BD%9C/","excerpt":"对hbase常规api进行封装","text":"对hbase常规api进行封装 hbase日常api类封装","categories":[],"tags":[{"name":"常规api封装","slug":"常规api封装","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%B8%B8%E8%A7%84api%E5%B0%81%E8%A3%85/"}]},{"title":"hadoop高可用模式搭建","slug":"日常总结/hadoop/hadoopHA搭建","date":"2019-05-15T16:00:00.000Z","updated":"2020-05-26T14:32:28.155Z","comments":true,"path":"2019/05/16/日常总结/hadoop/hadoopHA搭建/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/05/16/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/hadoop/hadoopHA%E6%90%AD%E5%BB%BA/","excerpt":"发现对hadoop的相关版本的组件,进程还有些模糊,借着针对hadoopHA模式搭建的过程,对hadoop进行一次细统的回顾.","text":"发现对hadoop的相关版本的组件,进程还有些模糊,借着针对hadoopHA模式搭建的过程,对hadoop进行一次细统的回顾. hadoop HA搭建与总结什么是HAHA即高可用 HA相关配置core-site.xml基本一致 hdfs-site.xml这里有明显差别hadoop2.X与hadoop1.X的高可能中的明显差异就是从这里开始的.2.x 引入了nameservice. 该nameservice可支持最大两个namenode.1.x img 和edits统一放置在namenode上.2.x 则通过journalnodes来共享edits日志. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;?xml-stylesheet type=\"text/xsl\" href=\"configuration.xsl\"?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt; &lt;!-- 为namenode集群定义一个services name --&gt; &lt;property&gt; &lt;name&gt;dfs.nameservices&lt;/name&gt; &lt;value&gt;ns1&lt;/value&gt; &lt;/property&gt; &lt;!-- nameservice 包含哪些namenode，为各个namenode起名 --&gt; &lt;property&gt; &lt;name&gt;dfs.ha.namenodes.ns1&lt;/name&gt; &lt;value&gt;namenode,datanode1&lt;/value&gt; &lt;/property&gt; &lt;!-- 名为master188的namenode的rpc地址和端口号，rpc用来和datanode通讯 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.rpc-address.ns1.namenode&lt;/name&gt; &lt;value&gt;namenode:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 名为master189的namenode的rpc地址和端口号，rpc用来和datanode通讯 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.rpc-address.ns1.datanode1&lt;/name&gt; &lt;value&gt;datanode1:9000&lt;/value&gt; &lt;/property&gt; &lt;!--名为master188的namenode的http地址和端口号，用来和web客户端通讯 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address.ns1.namenode&lt;/name&gt; &lt;value&gt;namenode:50070&lt;/value&gt; &lt;/property&gt; &lt;!-- 名为master189的namenode的http地址和端口号，用来和web客户端通讯 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address.ns1.datanode1&lt;/name&gt; &lt;value&gt;datanode1:50070&lt;/value&gt; &lt;/property&gt; &lt;!-- namenode间用于共享编辑日志的journal节点列表 --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt; &lt;value&gt;qjournal://namenode:8485;datanode1:8485;datanode2:8485/ns1&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定该集群出现故障时，是否自动切换到另一台namenode --&gt; &lt;property&gt; &lt;name&gt;dfs.ha.automatic-failover.enabled.ns1&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- journalnode 上用于存放edits日志的目录 --&gt; &lt;property&gt; &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/hadoop_store/dfs/data/dfs/journalnode&lt;/value&gt; &lt;/property&gt; &lt;!-- 客户端连接可用状态的NameNode所用的代理类 --&gt; &lt;property&gt; &lt;name&gt;dfs.client.failover.proxy.provider.ns1&lt;/name&gt; &lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt; &lt;/property&gt; &lt;!-- 一旦需要NameNode切换，使用ssh方式进行操作 --&gt; &lt;property&gt; &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt; &lt;value&gt;sshfence&lt;/value&gt; &lt;/property&gt; &lt;!-- 如果使用ssh进行故障切换，使用ssh通信时用的密钥存储的位置 --&gt; &lt;property&gt; &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt; &lt;value&gt;/home/hadoop/.ssh/id_rsa&lt;/value&gt; &lt;/property&gt; &lt;!-- connect-timeout超时时间 --&gt; &lt;property&gt; &lt;name&gt;dfs.ha.fencing.ssh.connect-timeout&lt;/name&gt; &lt;value&gt;30000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/hadoop_store/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/hadoop_store/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.replication&lt;/name&gt;&lt;value&gt;3&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; mapreduce-site.xml变动不大 yarn-site.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;?xml version=\"1.0\"?&gt;&lt;!-- Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file.--&gt;&lt;configuration&gt; &lt;!-- 启用HA高可用性 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.ha.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定resourcemanager的名字 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.cluster-id&lt;/name&gt; &lt;value&gt;yrc&lt;/value&gt; &lt;/property&gt; &lt;!-- 使用了2个resourcemanager,分别指定Resourcemanager的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.ha.rm-ids&lt;/name&gt; &lt;value&gt;rm1,rm2&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定rm1的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname.rm1&lt;/name&gt; &lt;value&gt;namenode&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定rm2的地址 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname.rm2&lt;/name&gt; &lt;value&gt;datanode1&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定当前机器master188作为rm1 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.ha.id&lt;/name&gt; &lt;value&gt;rm1&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定zookeeper集群机器 --&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.zk-address&lt;/name&gt; &lt;value&gt;namenode:2181,datanode1:2181,datanode2:2181&lt;/value&gt; &lt;/property&gt; &lt;!-- NodeManager上运行的附属服务，默认是mapreduce_shuffle --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;kuiqwang&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.log.server.url&lt;/name&gt; &lt;value&gt;http://namenode:19888/tmp/logs/hadoop/logs/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt; &lt;value&gt;/home/hadoop/hadoop_store/logs/yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.log-dirs&lt;/name&gt; &lt;value&gt;/home/hadoop/hadoop_store/logs/userlogs&lt;/value&gt; &lt;/property&gt;&lt;!--内存,核数大小配置 --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;4096&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;1024&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt; &lt;value&gt;3072&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.resource.mb&lt;/name&gt; &lt;value&gt;3072&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.command-opts&lt;/name&gt; &lt;value&gt;-Xmx3276m&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; HA过程中主要用到的操作命令当配置文件完成后,先启动journalnode,以助namenode 和standby node 共享edits文件hadoop-daemon.sh 然后再进行namdnode格式化,hadoop namenode -format进行namenode格式化当namenode格式化完成后可以先启动该节点的namenodehadoop-daemon.sh start namenode然后再在另一namdnode节点执行hdfs namenode -bootstrapStandby到这可以将之前的journalnode停用,然后start-dfs.sh 因为要用到zookeeper协助同步配置文件与操作日志,所以这里可以先对zookeeper进行hdfs内容的格式化hdfs zkfc –formatZK然后启动FailOver进程hadoop-daemon.sh start zkfc至此则是这些进程然后启用yarn.即start-yarn.sh到这里HA过程中用到的一些常用指令大致总结完成 至此 hadoop HA的常规总结完成.后续再补充一些细节,如standy 节点切的,与切换机制.HA背后的运作机制,与效果","categories":[],"tags":[]},{"title":"hdfs操作细节","slug":"日常总结/hadoop/hdfs/hdfs操作","date":"2019-05-15T16:00:00.000Z","updated":"2020-05-26T14:32:28.156Z","comments":true,"path":"2019/05/16/日常总结/hadoop/hdfs/hdfs操作/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2019/05/16/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/hadoop/hdfs/hdfs%E6%93%8D%E4%BD%9C/","excerpt":"针对hdfs一些较细节的api封装","text":"针对hdfs一些较细节的api封装 hdfs操作常规操作 创建文件 写数据 删除文件 上传文件 下载文件 断点续写 123错误： java.io.IOException: Failed to replace a bad datanode on the existing pipeline due to no more good datanodes being available to try 原因： 无法写入；我的环境中有3个datanode，备份数量设置的是3。在写操作时，它会在pipeline中写3个机器。默认replace-datanode-on-failure.policy是DEFAULT,如果系统中的datanode大于等于3，它会找另外一个datanode来拷贝。目前机器只有3台，因此只要一台datanode出问题，就一直无法写入成功。 1234567891011121314&lt;property&gt; &lt;name&gt;dfs.client.block.write.replace-datanode-on-failure.enable&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.client.block.write.replace-datanode-on-failure.policy&lt;/name&gt; &lt;value&gt;NEVER&lt;/value&gt; &lt;/property&gt; 对于dfs.client.block.write.replace-datanode-on-failure.enable，客户端在写失败的时候，是否使用更换策略，默认是true没有问题对于，dfs.client.block.write.replace-datanode-on-failure.policy，default在3个或以上备份的时候，是会尝试更换结点尝试写入datanode。而在两个备份的时候，不更换datanode，直接开始写。对于3个datanode的集群，只要一个节点没响应写入就会出问题，所以可以关掉。","categories":[],"tags":[]},{"title":"hive总结","slug":"日常总结/old/hive总结","date":"2018-12-24T15:07:45.000Z","updated":"2020-05-26T14:32:28.145Z","comments":true,"path":"2018/12/24/日常总结/old/hive总结/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2018/12/24/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/hive%E6%80%BB%E7%BB%93/","excerpt":"Hive相关点小结","text":"Hive相关点小结 启动指令 hive == hive –service cli不需要启动server，使用本地的metastore，可以直接做一些简单的数据操作和测试。 启动hiveserver2hive –service hiveserver2 beeline工具测试使用jdbc方式连接beeline -u jdbc:hive2://localhost:10000 1.managed table管理表。删除表时，数据也删除了 2.external table外部表。删除表时，数据不删 建表:CREATE TABLE IF NOT EXISTS t2(id int,name string,age int)COMMENT ‘xx’ //注释ROW FORMAT DELIMITED //行分隔符FIELDS TERMINATED BY ‘,’ //字段分隔符，这里使用的是逗号可以根据自己的需要自行进行修改STORED AS TEXTFILE ; 外部表: CREATE TABLE IF NOT EXISTS t2(id int,name string,age int) COMMENT ‘xx’ ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘,’ STORED AS TEXTFILE ; 分区表，桶表分区表Hive中有分区表的概念。我们可以看到分区表具有重要的性能，而且分区表还可以将数据以一种符合逻辑的方式进行组织，比如分层存储。Hive的分区表，是把数据放在满足条件的分区目录下CREATE TABLE t3(id int,name string,age int) PARTITIONED BY (Year INT, Month INT) //按照年月进行分区 ROW FORMAT DELIMITED //行分隔符 FIELDS TERMINATED BY ‘,’ ; //字段分隔符，这里使用的是逗号可以根据自己的需要自行进行修改load data local inpath ‘/home/zpx/customers.txt’ into table t3 partition 分桶表这样做，在查找数据的时候就可以跨越多个桶，直接查找复合条件的数据了。速度快，时间成本低。Hive中的桶表默认使用的机制也是hash。CREATE TABLE t4(id int,name string,age int) CLUSTERED BY (id) INTO 3 BUCKETS //创建3个通桶表，按照字段id进行分桶 ROW FORMAT DELIMITED //行分隔符 FIELDS TERMINATED BY &apos;,&apos; ; load data local inpath ‘/home/centos/customers.txt’ into table t4 ; 导入数据load data local inpath ‘/home/zpx/customers.txt’ into table t2 ; //local上传文件load data inpath ‘/user/zpx/customers.txt’ [overwrite] into table t2 //分布式文件系统上移动文件 建视图Hive也可以建立视图，是一张虚表，方便我们进行操作. create view v1 as select a.id aid,a.name ,b.id bid , b.order from customers a left outer join default.tt b on a.id = b.cid ; Hive的严格模式Hive提供了一个严格模式，可以防止用户执行那些产生意想不到的不好的影响的查询。使用了严格模式之后主要对以下3种不良操作进行控制： 1.分区表必须指定分区进行查询。2.order by时必须使用limit子句。3.不允许笛卡尔积。 Hive的动态分区像分区表里面存储了数据。我们在进行存储数据的时候，都是明确的指定了分区。在这个过程中Hive也提供了一种比较任性化的操作，就是动态分区，不需要我们指定分区目录，Hive能够把数据进行动态的分发,我们需要将当前的严格模式设置成非严格模式，否则不允许使用动态分区set hive.exec.dynamic.partition.mode=nonstrict//设置非严格模式 Hive的排序Hive也提供了一些排序的语法，包括order by,sort by。 order by=MapReduce的全排序sort by=MapReduce的部分排序distribute by=MapReduce的分区 selece …….from …… order by 字段；//按照这个字段全排序 selece …….from …… sort by 字段； //按照这个字段局部有序 selece 字段…..from …… distribute by 字段；//按照这个字段分区特别注意的是： 在上面的最后一个distribute by使用过程中，按照排序的字段要出现在最左侧也就是select中有这个字段，因为我们要告诉MapReduce你要按照哪一个字段分区，当然获取的数据中要出现这个字段了。类似于我们使用group by的用法，字段也必须出现在最左侧，因为数据要包含这个字段，才能按照这个字段分组，至于Hive什么时候会自行的开启MapReduce，那就是在使用聚合的情况下开启，使用select …from ….以及使用分区表的selece ….from……where …..不会开启 distribute by与sort by可以组合使用，但是distribute by要放在前边，因为MapReduce要先分区，后排序，再归并 select 字段a,……..from …….distribute by字段a，sort by字段如果distribute by与sort by使用的字段一样，则可以使用cluster by 字段替代：select 字段a,……..from …….cluster by 字段 函数 show functions; 展示相关函数 desc function split; desc function extended split; //查看函数的扩展信息 用户自定义函数（UDF）具体步骤如下： （1）.自定义类（继承UDF，或是GenericUDF。GenericUDF是更为复杂的抽象概念，但是其支持更好的null值处理同时还可以处理一些标准的UDF无法支持的编程操作）。（2）.导出jar包，通过命令添加到hive的类路径。$hive&gt;add jar xxx.jar（3）.注册函数$hive&gt;CREATE TEMPORARY FUNCTION 函数名 AS ‘具体类路径：包.类’;（4）.使用 $hive&gt;select 函数名(参数);自定义实现类如下(继承UDF)：","categories":[],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"http://www.wqkenqing.ren/daydoc/tags/bigdata/"}]},{"title":"hbase积累.md","slug":"日常总结/old/hbase积累","date":"2018-06-04T02:54:48.000Z","updated":"2020-05-26T14:32:28.141Z","comments":true,"path":"2018/06/04/日常总结/old/hbase积累/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2018/06/04/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/hbase%E7%A7%AF%E7%B4%AF/","excerpt":"hbase积累","text":"hbase积累 细节点1.Rowkey设计原则 1.1 长度原则 rowkey 在hbase以二进制码流,可以是任意字符串, 最大长度是64kb,实际应用主要是100~100bytes 长度尽量为8的整数倍,因为现在的系统主要是64位,内存8字节对齐.控制在16字节,符合操作系统特性 1.2 散列原则:因为hbase是分布式存储,rowkey的高位尽量是散列字段,散列性弱的尽量放在低位段.如Time AND Device_id的组合,相对而言device_id 应该量级较小,散列性高.而TIME散列性低,如果TIME放在高位,可能造成数据在某个RegeionServer上堆积的情况.所以较合理的rowkey组合应是device_id+time. 1.3 RowKey唯一原则：必须在设计上保证其唯一性.hbase 中以KeyValue形式存储,key若重复,行内容则会被覆盖. 2.Hbase的Regeion热点问题解决因为在创建表是没有提前预分区,创建的表默认就只会有一个region,这个region的rowkey是没有边界的,即没有startkey与stopkey.数据在写入时,都会写入到这个region.随着数据的不断增加,达到某个阈值时,才会split成2个region.在这个过程中就会产生所有数据囤积在一个regionServer上,出现热点问题.另在split时,会占用集群的I/O资源.通过预分区可以解决该问题 2.1 预分区预分区,”预”字是核心.我们在建表时,预先对表中要存放的数据形式和可能的量级,心中必然会有所估量,即这里应预估数据量.若数据量较大,则在建表时又应该预分区.即根据数据形式,量级,事先预设好一定量的region,后面数据写入时,则会写入到相应的分区.从而避免热点,减少split. 2.1.2 salting(加盐)hbase rowkey设计,避免热点,常会用到该操作,这里的加盐本身不是加密操作,而是在原数据前加入一些随机数据,从而起到分散不同region的作用. 2.1.3 预习区具体方案 hbase预分区的相关操作,如shell形式,可直接在hbase shell操作.如 [https://blog.csdn.net/xiao_jun_0820/article/details/24419793](Hbase shell 预分区操作.) java形式[https://blog.csdn.net/qq_20641565/article/details/56482407](Hbase 预分区 java API形式) 以上操作形式有个问题就是rowkey是随机生成的,虽起到了散列存储,避免了热点堆积,但因为加盐的缘故,想要直接的获取某行数据较为困难.若针对的是高频使用的数据,则会出现问题. 2.1.4 hash分区 在原先预分区的基础上,通过相关规则将原数据hash,从而获得这个原数据对应在哪个分区,使当拿到相关原数据,就能推演出相关rowkey.从而能准确的get数据. hbase优化确定优化目标沟通交流后，业务方更看重降低成本。数据量梳理后略有降低，保证吞吐，无长期请求堆积前提下可以放宽延时要求。为了更快的进行优化，放宽稳定性可以要求接受短期波动。另外，该分组的RegionServer之前存在不稳定的问题，这次优化也一并解决。","categories":[],"tags":[{"name":"日常总结","slug":"日常总结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"}]},{"title":"spark学习","slug":"日常总结/old/spark学习","date":"2018-03-04T03:12:58.000Z","updated":"2020-05-26T14:32:28.143Z","comments":true,"path":"2018/03/04/日常总结/old/spark学习/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2018/03/04/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/spark%E5%AD%A6%E4%B9%A0/","excerpt":"spark 学习","text":"spark 学习 1spark 作为主流的实时计算引擎,需要高度掌握 spark介绍Apache Spark是一用于实时处理的开源集群计算框架.持多种语言编程,Spark Streaming有高吞吐量和容错能力强等特点.数据输入后可以用Spark的高度抽象原语如：map、reduce、join、window等进行运算,而结果也能保存在很多地方，如HDFS，数据库等。另外Spark Streaming也能和MLlib（机器学习）以及Graphx完美融合。 优点 易用 容错 spark体系整合 RDD详解RDD是什么RDD：Spark的核心概念是RDD (resilientdistributed dataset)，指的是一个只读的，可分区的分布式数据集，这个数据集的全部或部分可以缓存在内存中，在多次计算间重用。 另:RDD即弹性分布式数据集，有容错机制并可以被并行操作的元素集合，具有只读、分区、容错、高效、无需物化、可以缓存、RDD依赖等特征。RDD只是数据集的抽象，分区内部并不会存储具体的数据。 RDD的五个特性 有一个分片列表。就是能被切分，和hadoop一样的，能够切分的数据才能并行计算。 有一个函数计算每一个分片，这里指的是下面会提到的compute函数. 对其他的RDD的依赖列表，依赖还具体分为宽依赖和窄依赖，但并不是所有的RDD都有依赖. 可选：key-value型的RDD是根据哈希来分区的，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce。 可选：每一个分片的优先计算位置（preferred locations），比如HDFS的block的所在位置应该是优先计算的位置。(存储的是一个表，可以将处理的分区“本地化”). 12345678910//只计算一次 protected def getPartitions: Array[Partition] //对一个分片进行计算，得出一个可遍历的结果 def compute(split: Partition, context: TaskContext): Iterator[T] //只计算一次，计算RDD对父RDD的依赖 protected def getDependencies: Seq[Dependency[_]] = deps //可选的，分区的方法，针对第4点，类似于mapreduce当中的Paritioner接口，控制key分到哪个reduce @transient val partitioner: Option[Partitioner] = None //可选的，指定优先位置，输入参数是split分片，输出结果是一组优先的节点位置 protected def getPreferredLocations(split: Partition): Seq[String] = Nil 为什么会产生RDDRDD数据集 并行集合 接收一个已经存在的集合,然后进行各种并行计算.并行化集合是通过调用SparkContext的parallelize方法，在一个已经存在的Scala集合上创建（一个Seq对象）。集合的对象将会被拷贝，创建出一个可以被并行操作的分布式数据集。 Hadoop数据集 Spark可以将任何Hadoop所支持的存储资源转化成RDD，只要文件系统是HDFS，或者Hadoop支持的任意存储系统即可，如本地文件（需要网络文件系统，所有的节点都必须能访问到）、HDFS、Cassandra、HBase、Amazon S3等，Spark支持文本文件、SequenceFiles和任何Hadoop InputFormat格式。 此两种类型的RDD都可以通过相同的方式进行操作，从而获得子RDD等一系列拓展，形成lineage血统关系图。 Spark RDD算子 Transformation不触发提交作业，完成作业中间处理过程。 DStream什么是DStreamDiscretized Stream :代表持续性的数据流和经过各种Spark原语操作后的结果数据流,在内部实现上是一系列连续的RDD来表示.每个RDD含有一段时间间隔内的数据,如下图 计算则由spark engine来完成 spark java因为我是主要掌握的语言是java,从效率上来考虑,这里 参考博客https://blog.csdn.net/wangxiaotongfan/article/details/51395769 RDD详解https://blog.csdn.net/zuochang_liu/article/details/81459185 spark streaming学习https://blog.csdn.net/hellozhxy/article/details/81672845 spark java 使用指南https://blog.csdn.net/t1dmzks/article/details/70198430 sparkRDD算子介绍https://blog.csdn.net/wxycx11111/article/details/79123482 sparkRDD入门介绍https://github.com/zhaikaishun/spark_tutorial RDD算子介绍","categories":[],"tags":[{"name":"学习spark","slug":"学习spark","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%AD%A6%E4%B9%A0spark/"}]},{"title":"spark学习2","slug":"日常总结/old/spark学习2","date":"2018-03-04T03:12:58.000Z","updated":"2020-05-26T14:32:28.150Z","comments":true,"path":"2018/03/04/日常总结/old/spark学习2/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2018/03/04/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/spark%E5%AD%A6%E4%B9%A02/","excerpt":"spark学习2spark 运行的四种模式","text":"spark学习2spark 运行的四种模式 本地模式如 1.&#x2F;bin&#x2F;spark-submit --class org.apache.spark.examples.SparkPi --master local[1] .&#x2F;lib&#x2F;spark-examples-1.3.1-hadoop2.4.0.jar 100 standlone模式client./bin/spark-submit –class org.apache.spark.examples.SparkPi –master spark://spark001:7077 –executor-memory 1G –total-executor-cores 1 ./lib/spark-examples-1.3.1-hadoop2.4.0.jar 100 cluster./bin/spark-submit –class org.apache.spark.examples.SparkPi –master spark://spark001:7077 –deploy-mode cluster –supervise –executor-memory 1G –total-executor-cores 1 ./lib/spark-examples-1.3.1-hadoop2.7.0.jar 100 Yarn模式client模式123client模式：结果xshell可见：.&#x2F;bin&#x2F;spark-submit --class org.apache.spark.examples.SparkPi --master yarn-client --executor-memory 1G --num-executors 1 .&#x2F;lib&#x2F;spark-examples-1.3.1-hadoop2.7.0.jar 100 cluster模式./bin/spark-submit –class org.apache.spark.examples.SparkPi –master yarn-cluster –executor-memory 1G –num-executors 1 ./lib/spark-examples-1.3.1-hadoop2.4.0.jar 100 spark sql","categories":[],"tags":[{"name":"学习spark2","slug":"学习spark2","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%AD%A6%E4%B9%A0spark2/"}]},{"title":"spark算子","slug":"日常总结/old/spark算子","date":"2018-03-04T03:12:05.000Z","updated":"2020-05-26T14:32:28.146Z","comments":true,"path":"2018/03/04/日常总结/old/spark算子/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2018/03/04/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/spark%E7%AE%97%E5%AD%90/","excerpt":"spark 算子","text":"spark 算子 123sparkRDD封装的函数方法又称算子,通过这些算子可以对RDD进行相关处理,从而获我们想要的结果,因为可能涉及的算子较多.因此单独开篇进行粒度更细,更集中的总结.总得来讲spark的算子,本就是scala集合的一些高阶用法. Transformation(转换)不触发提交作业，完成作业中间处理过程。 parallelize (并行化)将一个存在的集合，变成一个RDD ,返回的是一个JavaRDD[T]** in scala ** 1sc.parallelize(List(\"shenzhen\", \"is a beautiful city\")) ** in java ** 1JavaRDD&lt;String&gt; javaStringRDD = sc.parallelize(Arrays.asList(\"shenzhen\", \"is a beautiful city\")); makeRDD只有scala版本的才有makeRDD ,与parallelize类似. textFile调用SparkContext.textFile()方法，从外部存储中读取数据来创建 RDD** in scala ** 1var lines = sc.textFile(inpath) 12// java JavaRDD&lt;String&gt; lines = sc.textFile(inpath); filter对RDD数据进行过滤 map接收一个函数,并将这个函数作用于RDD中的每个元素.RDD 中对应*元素的值 map是一对一的关系 * flatMap有时候，我们希望对某个元素生成多个元素，实现该功能的操作叫作 flatMap() ,faltMap的函数应用于每一个元素，对于每一个元素返回的是多个元素组成的迭代器 distinct去重,我们生成的RDD可能有重复的元素，使用distinct方法可以去掉重复的元素, 不过此方法涉及到混洗，操作开销很大 union两个RDD进行合并 intersectionRDD1.intersection(RDD2) 返回两个RDD的交集，** 并且去重 **intersection 需要混洗数据，比较浪费性能 subtractRDD1.subtract(RDD2),返回在RDD1中出现，但是不在RDD2中出现的元素，不去重 cartesiancartesian(RDD2) 返回RDD1和RDD2的笛卡儿积，这个开销非常大 mapToPair将元素该成key-value形式 flatMapToPair差异同mapToPair combineByKey该方法主要针对不同分区的同一key进行元素合并函数操作.需要对pairRDD进行 createCombiner 会遍历分区中的所有元素，因此每个元素的键要么还没有遇到过,要么就和之前的某个元素的键相同。如果这是一个新的元素， combineByKey() 会使用一个叫作 createCombiner() 的函数来创建那个键对应的累加器的初始值 mergeValue 如果这是一个在处理当前分区之前已经遇到的键， 它会使用 mergeValue() 方法将该键的累加器对应的当前值与这个新的值进行合并 mergeCombiners 于每个分区都是独立处理的， 因此对于同一个键可以有多个累加器。如果有两个或者更多的分区都有对应同一个键的累加器， 就需要使用用户提供的 mergeCombiners() 方法将各个分区的结果进行合并。reduceByKey接收一个函数，按照相同的key进行reduce操foldByKey该函数用于RDD[K,V]根据K将V做折叠、合并处理，其中的参数zeroValue表示先根据映射函数将zeroValue应用于V,进行初始化V,再将映射函数应用于初始化后的V ,与reduce不同的是 foldByKey开始折叠的第一个元素不是集合中的第一个元素，而是传入的一个元素 sortByKeySortByKey用于对pairRDD按照key进行排序，第一个参数可以设置true或者false，默认是true groupByKeygroupByKey会将RDD[key,value] 按照相同的key进行分组，形成RDD[key,Iterable[value]]的形式， 有点类似于sql中的groupby，例如类似于mysql中的group_concat cogroupgroupByKey是对单个 RDD 的数据进行分组，还可以使用一个叫作 cogroup() 的函数对多个共享同一个键的 RDD 进行分组RDD1.cogroup(RDD2) 会将RDD1和RDD2按照相同的key进行分组，得到(key,RDD[key,Iterable[value1],Iterable[value2]])的形式 subtractByKey类似于subtrac，删掉 RDD 中键与 other RDD 中的键相同的元素join可以把RDD1,RDD2中的相同的key给连接起来，类似于sql中的join操作RDD1.join(RDD2) fullOuterJoin全连接leftOuterJoinrightOuterJoin Actionfirst返回第一个元素 takerdd.take(n)返回第n个元素 collectrdd.collect() 返回 RDD 中的所有元素 countrdd.count() 返回 RDD 中的元素个数 countByValue各元素在 RDD 中出现的次数 返回{(key1,次数),(key2,次数),…(keyn,次数)} reduce并行整合RDD中所有数据 fold和 reduce() 一 样， 但是提供了初始值num,每个元素计算时，先要合这个初始值进行折叠, 注意，这里会按照每个分区进行fold，然后分区之间还会再次进行fold toprdd.top(n)按照降序的或者指定的排序规则，返回前n个元素 takeOrderedrdd.take(n)对RDD元素进行升序排序,取出前n个元素并返回，也可以自定义比较器（这里不介绍），类似于top的相反的方法 foreach对 RDD 中的每个元素使用给定的函数 countByKey以RDD{(1, 2),(2,4),(2,5), (3, 4),(3,5), (3, 6)}为例 rdd.countByKey会返回{(1,1),(2,2),(3,3)} collectAsMap将pair类型(键值对类型)的RDD转换成map, 还是上面的例子 saveAsTextFilesaveAsTextFile用于将RDD以文本文件的格式存储到文件系统中。 saveAsSequenceFilesaveAsSequenceFile用于将RDD以SequenceFile的文件格式保存到HDFS上。 saveAsObjectFilesaveAsObjectFile用于将RDD中的元素序列化成对象，存储到文件中。 saveAsHadoopFilesaveAsNewAPIHadoopFilemapPartitionsmapPartitionsWithIndexHashPartitionerRangePartitioner自定义分区","categories":[],"tags":[{"name":"spark学习","slug":"spark学习","permalink":"http://www.wqkenqing.ren/daydoc/tags/spark%E5%AD%A6%E4%B9%A0/"}]},{"title":"sqoop记录","slug":"日常总结/old/sqoop记录","date":"2018-03-04T02:54:48.000Z","updated":"2020-05-26T14:32:28.140Z","comments":true,"path":"2018/03/04/日常总结/old/sqoop记录/","link":"","permalink":"http://www.wqkenqing.ren/daydoc/2018/03/04/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/old/sqoop%E8%AE%B0%E5%BD%95/","excerpt":"将Mysql数据导入Hive中","text":"将Mysql数据导入Hive中 命令: 12345678sqoop import -Dorg.apache.sqoop.splitter.allow_text_splitter&#x3D;true --connect jdbc:mysql:&#x2F;&#x2F;211.159.172.76:3306&#x2F;solo--username root --password 125323Wkq --table tablename --hive-import --hive-table tablename 整库导入1234sqoop import-all-tables --connect jdbc:mysql:&#x2F;&#x2F;211.159.172.76:3306&#x2F; --username root --password 125323Wkq --hive-database solo -m 10 --create-hive-table --fields-terminated-by &quot;\\t&quot;--hive-import --hive-database qianyang --hive-overwrite sqoop import-all-tables -Dorg.apache.sqoop.splitter.allow_text_splitter=true –connect jdbc:mysql://211.159.172.76:3306/solo –username root –password 125323Wkq –hive-database blog –create-hive-table –hive-import –hive-overwrite -m 10 单表导入sqoop import –connect jdbc:mysql://211.159.172.76:3306/solo –username root –password 125323Wkq –table b3_solo_article –target-dir /blog/article –hive-import –hive-database blog–fields-terminated-by “\\t” –hive-table article –hive-overwrite–m 10 sqoop import –connect jdbc:mysql://211.159.172.76:3306/solo –username root –password 125323Wkq –table b3_solo_article –target-dir /blog/article –hive-import –hive-database blog –create-hive-table –hive-table article –hive-overwrite -m 1","categories":[],"tags":[{"name":"日常总结","slug":"日常总结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"}]}],"categories":[],"tags":[{"name":"python learn","slug":"python-learn","permalink":"http://www.wqkenqing.ren/daydoc/tags/python-learn/"},{"name":"es feild script","slug":"es-feild-script","permalink":"http://www.wqkenqing.ren/daydoc/tags/es-feild-script/"},{"name":"elasticsearch kibana head vscode","slug":"elasticsearch-kibana-head-vscode","permalink":"http://www.wqkenqing.ren/daydoc/tags/elasticsearch-kibana-head-vscode/"},{"name":"elasticsearch drawio","slug":"elasticsearch-drawio","permalink":"http://www.wqkenqing.ren/daydoc/tags/elasticsearch-drawio/"},{"name":"DDNS","slug":"DDNS","permalink":"http://www.wqkenqing.ren/daydoc/tags/DDNS/"},{"name":"mac os & windows","slug":"mac-os-windows","permalink":"http://www.wqkenqing.ren/daydoc/tags/mac-os-windows/"},{"name":"tmux","slug":"tmux","permalink":"http://www.wqkenqing.ren/daydoc/tags/tmux/"},{"name":"cvim","slug":"cvim","permalink":"http://www.wqkenqing.ren/daydoc/tags/cvim/"},{"name":"kafka","slug":"kafka","permalink":"http://www.wqkenqing.ren/daydoc/tags/kafka/"},{"name":"日常总结","slug":"日常总结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"},{"name":"bigdata","slug":"bigdata","permalink":"http://www.wqkenqing.ren/daydoc/tags/bigdata/"},{"name":"运维 cdn 加速","slug":"运维-cdn-加速","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E8%BF%90%E7%BB%B4-cdn-%E5%8A%A0%E9%80%9F/"},{"name":"小结","slug":"小结","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%B0%8F%E7%BB%93/"},{"name":"spark es kafka","slug":"spark-es-kafka","permalink":"http://www.wqkenqing.ren/daydoc/tags/spark-es-kafka/"},{"name":"flink","slug":"flink","permalink":"http://www.wqkenqing.ren/daydoc/tags/flink/"},{"name":"hdfs","slug":"hdfs","permalink":"http://www.wqkenqing.ren/daydoc/tags/hdfs/"},{"name":"sparkstreaming","slug":"sparkstreaming","permalink":"http://www.wqkenqing.ren/daydoc/tags/sparkstreaming/"},{"name":"spark dependency","slug":"spark-dependency","permalink":"http://www.wqkenqing.ren/daydoc/tags/spark-dependency/"},{"name":"sparkstream","slug":"sparkstream","permalink":"http://www.wqkenqing.ren/daydoc/tags/sparkstream/"},{"name":"常规api封装","slug":"常规api封装","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%B8%B8%E8%A7%84api%E5%B0%81%E8%A3%85/"},{"name":"学习spark","slug":"学习spark","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%AD%A6%E4%B9%A0spark/"},{"name":"学习spark2","slug":"学习spark2","permalink":"http://www.wqkenqing.ren/daydoc/tags/%E5%AD%A6%E4%B9%A0spark2/"},{"name":"spark学习","slug":"spark学习","permalink":"http://www.wqkenqing.ren/daydoc/tags/spark%E5%AD%A6%E4%B9%A0/"}]}
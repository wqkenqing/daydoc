title:  c learn
date:  2023年 3月 7日
tags: [c、考研、复试]
password: 7FKBKZrTTTPG2LnC

---

考研复试、程序设计

 <!--more-->

# 程序设计 （C）

## 1、数据类型&运算符&表达式



#### 1.1 C程序常见符号分类

1. 关键字(keyword)
2. 标识符(identifier)
   1. 标识符分为系统预定义标识符和用户自定义标识符两类。
3. 运算符(Operator)
   1. ![CleanShot 2023-03-16 at 14.37.09@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2014.37.09@2x.png)

![CleanShot 2023-03-16 at 15.49.57@2x](/Users/kuiqwang/Library/Application%20Support/CleanShot/media/media_9OqdQ0K5yL/CleanShot%202023-03-16%20at%2015.49.57@2x.png)

 	4. 分隔符 (Separator )
 	 	1. 就像写文章要有标点符号 一样，写程序也要有 一些分隔符。在 C 程序中，空格、回车/ 换行、逗号等，在各自不同的应用场合起着分隔符的作用。

**C 语 言 提 供 的 数 据 类 型 (D a t a T y p e ) 分 类 如 下**

​	![CleanShot 2023-03-16 at 15.52.07@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2015.52.07@2x.png)

### 1.2 基本数据类型有三种:

1. 字符(char)
2.  整数(int)
3. 和浮点数(float)。

复杂的类型都是基于它们构建的。

#### 1.2.1**字符类型**

```
上面示例中，变量 t 为单引号字符，由于字符常量必须放在单引号里面，所以内部的单引号要使用反斜杠转 义。
这种转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值。
\a :警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。
\b :退格键，光标回退一个字符，但不删除字符。
\f :换⻚符，光标移到下一⻚。在现代系统上，这已经反映不出来了，行为改成类似于 \v 。 \n :换行符。
\r :回⻋符，光标移到同一行的开头。
\t :制表符，光标移到下一个水平制表位，通常是下一个8的倍数。
\v :垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。
\0 :null 字符，代表没有内容。注意，这个值不等于数字0。
转义写法还能使用八进制和十六进制表示一个字符。 \nn :字符的八进制写法， nn 为八进制值。
\xnn :字符的十六进制写法， nn 为十六进制值。
```



```
char x = 'B';
char x = 66;
char x = '\102'; // 八进制 char x = '\x42'; // 十六进制
```



#### 1.2.2**整数类型**

整数类型用来表示较大的整数，类型声明使用 int 关键字。

```
int a;
```

```markdown
不同计算机的 int 类型的大小是不一样的。比较常⻅的是使用4个字节(32位)存储一个 int 类型的值，但
是2个字节(16位)或8个字节(64位)也有可能使用。它们可以表示的整数范围如下。
16位:-32,768 到 32,767。
32位:-2,147,483,648 到 2,147,483,647。 64位:-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。

```

**signed，unsigned**

C 语言使用 signed 关键字，表示一个类型带有正负号，包含负值;使用 unsigned 关键字，表示该类型不 带有正负号，只能表示零和正整数。

对于 int 类型，默认是带有正负号的，也就是说 int 等同于 signed int 。由于这是默认情况，关键 字 signed 一般都省略不写，但是写了也不算错。

```markdown
signed int a;
// 等同于
int a;
```

int 类型也可以不带正负号，只表示非负整数。这时就必须使用关键字 unsigned 声明变量。

```markdown
unsigned int a;
```

整数变量声明为 unsigned 的好处是，同样⻓度的内存能够表示的最大整数值，增大了一倍。比如，16位 的 signed int 最大值为32,767，而 unsigned int 的最大值增大到了65,535。

unsigned int 里面的 int 可以省略，所以上面的变量声明也可以写成下面这样。

```markdown
unsigned a;
```

字符类型 char 也可以设置 signed 和 unsigned 。

```
signed char c; // 范围为 -128 到 127 
unsigned char c; // 范围为 0 到 255
```

注意，C 语言规定 char 类型默认是否带有正负号，由当前系统决定。这就是说， char 不等同于 signed char ，它有可能是 signed char ，也有可能是 unsigned char 。这一点与 int 不同， int 就是等同于signed int 。

**整数的子类型**

如果 int 类型使用4个或8个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需 要更大的整数，8个字节还不够。为了解决这些问题，C 语言在 int 类型之外，又提供了三个整数的子类 型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图。

```markdown
short int (简写为 short ):占用空间不多于 int ，一般占用2个字节(整数范围为-32768~ 32767)。
long int (简写为 long ):占用空间不少于 int ，至少为4个字节。
long long int (简写为 long long ):占用空间多于 long ，至少为8个字节。
```

```markdown
short int a;
long int b;
long long int c;
```

默认情况下， short 、 long 、 long long 都是带符号的(signed)，即 signed 关键字省略了。它们也

可以声明为不带符号(unsigned)，使得能够表示的最大值扩大一倍。

```
unsigned short int a;
unsigned long int b;
unsigned long long int c;
```

C 语言允许省略 int ，所以变量声明语句也可以写成下面这样

```markdown
short a;
unsigned short a;
long b;
unsigned long b;
long long c;
unsigned long long c;
```

不同的计算机，数据类型的字节⻓度是不一样的。确实需要32位整数时，应使用 long 类型而不是 int 类 型，可以确保不少于4个字节;

确实需要64位的整数时，应该使用 long long 类型，可以确保不少于8个字 节。另一方面，为了节省空间，只需要16位整数时，应使用 short 类型;需要8位整数时，应该使用 char 类型。

#### 1.2.3 **标识符命名**

标识符的命名必须遵循一定的规则。这里只介绍被大多数程序员所采纳的共性规则。一 般 的 标 识 符 命 名 规 则 (N a m i n g R u l e s ）

1. 由英文字母、数字和下画线组成，且必须以英文字母或下画线开头。
2.  不 允 许 使 用 关 键 字 作 为 标 识 符 的 名 字， 同 时 标 识 符 名 也 不 应 该 与 库 函 数 名 重 名 。
3. 在C 语言中，标识符可以是任意长度的。
4. 标识符命名应以直观且易于拼读为宜。
5. 命名规则应尽量与所采用的操作系统或开发工具的风格保持 一致。

6. 标识符区分大小写

#### 1.2.4 **常量**



常量(Constant)是一种在程序中保持类型和值都不变的数据。按照类型划分有以下几种常量：整型常量、实型常量、字符常量、字符串常量、枚举常量。除枚举类型外，编译系统从它们的数据表示形式上就能区分它们的类型。

计算机中的数据都以二进制形式存储。在C程序中，为便于表示和使用，整型常量可用

1. 十进制(Decimal)
2. 八进制(Octal)
3. 十六进制(Hexadecimal)

三种形式来表示，编译系统会自动将其转换为二进制形式存储。整型常量的表示形式如表2-1所示。

![CleanShot 2023-03-16 at 16.10.53@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.10.53@2x.png)

2.整型常量的类型确定

长整型常量由常量值后跟L或1来表示，如-2561、1024L等。
无符号整型常量由常量值后跟U或u来表示，如30u、256U等，但不能表示成小于0 的数（如-30u)。无符号长整型常量由常量值后跟LU、Lu、IU或lu来表示，如30lu等。

**实型常量**

1.实型(Float)常量的表示形式

(1)十进制小数形式

```markdown
十进制小数形式与人们表示实数的惯用形式相同，是由数字和小数点组成的。注意，必须有小数点，如0.123、-12.35、.98、18.等都是合法的表示形式，其中，98等价于0.98,18.
等价于18.0。如果没有小数点，则不能作为小数形式的实型数。
```

(2)指数形式

```markdown
在实际应用中，有时会遇到绝对值很大或很小的数。这时，我们将其写成指数形式，更直观、方便，如0.00000345写成3.45×106，或者0.345×10~7。程序编辑时不能输入角标，因此在C语言中，以字母e或E来代表以10为底的指数。如0.00000345写成3.45e-6,或者0.345e-5。其中，e的左边是数值部分（有效数字），可以表示成整数或者小数形式，它不能省略：e的右边是指数部分，必须是整数形式。例如，3e-2、3.0e-2、3.e-2、.6e-2等都是合法的表示形式，而e3、2e3.0、.e3等都是不合法的表示形式。
```

2.实型常量的类型确定

```
实型常量隐含按双精度型（double)处理。
单精度实型常量由常量值后跟F或f来表示，如1.25F、1.25e-2f等。
长双精度(long double)实型常量由常量值后跟L或1来表示，如l.25L等。
```

**字符常量**

```markdown
C语言中的字符常量是由单引号括起来的一个字符，如'a'、2'、#等。字符常量两侧的一对单引号是必不可少的，如B是字符常量，而B则是一个标识符；再如，3表示一个字符， 而3则表示一个整数。为了表示某些控制字符（如回车符、换行符等），C语言中还引入了另一种特殊形式的字符常量一转义序列(Escape Sequence),它是以反斜线“”开头的字符序列，使用时同样要括在一对单引号内。这里的反斜线“1”有着特殊的含义，编译器会将其视为转义字符(Escape Character)。当编译器遇到字符串中的转义字符时，它会将转义字符及其下一个字符组成一个转义序列。常用的转义序列及其含义见表2-2。
```

![CleanShot 2023-03-16 at 16.34.49@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.34.49@2x.png)

**字符串常量**

字符串常量是由一对双引号括起来的一个字符序列，如"qwe"、"123"、"w"等都是字符串。注意，"a"是字符串常量，不是字符常量，'a'才是字符常量。
为便于C程序判断字符串是否结束，系统对每个用双引号括起来的字符串常量都添加一个字符串结束标志一A$CⅡ码值为0的空操作符"\0"。它不引起任何控制动作，也不显示。

**宏常量**

宏常量，也称符号常量(Symbolic Names or Constants),是指用一个标识符号代表的个常量，这时该标识符号与此常量是等价的。宏常量是由C语言中的宏定义编译处理命令来定义的。宏定义的一般形式为：

#define 标识符字符串

其作用是用#define编译预处理指令定义一个标识符和一个字符串，凡在源程序中发现该标识符时，都用其后指定的字符串来替换。宏定义中的标识符被称为宏名(Macro Name),将程序中出现的宏名替换成字符串的过程称为宏替换(Macro Substitution)。宏名与字符串之间可以有多个空白符，但字符串后只能以换行符终止，且除非特殊需要一般不出现分号。

例如： #define PI 3.14159 

它的作用是在编译预处理时，把程序中在该命令之后出现的所有标识符PI均用3.14159代替。

其优点在于，能使用户以一个简单的名字代替一个长的字符串，提高程序的可读性。

![CleanShot 2023-03-16 at 16.39.31@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.39.31@2x.png)

**枚举常量**

```markdown
所谓“枚举(Enumeration)”就是一一列举之意，当某些量仅由有限个数据值组成时， 通常用枚举类型来表示。枚举数据类型(Enumerated Data Type)描述的是一组整型值的集合， 可用关键字enum来定义这种类型。
例如： enum response(no,yes,none); enum response answer; 
这两条语句首先声明了名为response的枚举数据类型，
它有三种可能的取值：no、yes、none,然后用该枚举类型定义了一个名为answer的变量。
在枚举类型声明语句中，包含在花括号内的标识符均为整型常量，称为枚举常量。
除非特别指定，否则这组常量中的第1个常量的值为0，第2个常量的值为1，第3个常量的值为2,以后依次递增1。
在上例中，变量answer可被赋予no、yes、none这三种值中的任何一种。
例如： answer no 相当于： answer =0; 变量answer还可以用在条件语句中，例如： 
if (answer ==yes) 
相当于： if (answer ==1) 使用枚举类型的目的是提高程序的可读性。
例如，在上例中，使用no、yes、none比使用0、1、2的程序可读性更好。
在上例中，response被称为枚举标记(Enumeration Tag),枚举标记是可选的(Optional), 也可以省略不写。
例如： enum(no,yes,nonelanswer; C语言还允许在枚举类型定义时，明确地设置每一个枚举常量的值，
例如： enum response(no =-1,yes =1,none =0}; 若要在枚举类型定义中增加一种可能的取值，那么在“{”和“}”之间直接添加即可。
例如： enum response(no =-1, yes =1,none =0,unsure 2); 
其他类似的例子还有： enum month{JAN=1,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC}; 
这里，第一个枚举常量值被明确地设置为1，以下的常量值依次递增1。再如：
```

```
理解枚举类型的要点是：枚举标记后面变量表中的每个标识符都代表一个整型常数
这些标识符只是一个整型常数的名字，不是字符串，因此它们可以用于使用整型常数值的任何场合，但不能将其作为字符串直接输入和输出。
例如下面的语句并不能达到输出字符串"yes" 的目的。
answer 1; 
printf("%s",answer);/错误
```

#### 1.2.5 **变量**



**变量的定义与初始化**

```markdown
整型的类型关键字为int,单精度实型的类型关键字为float,双精度实型的类型关键字为double,字符型的类型关键字为char。
变量类型决定了编译器为其分配的内存单元的字节数、内存单元中能存放哪种类型的数据、数据在内存中的存储形式、该类型变量合法的取值范围及可参与的运算种类。
例如： short max; //等价于语句short 
int max; long sum; //等价于1ong int sum; 
unsigned int area;/定义area为无符号整型变量
float score; //定义score为单精度实型变量
double total; //定义tota1为双精度实型变量
char sex; //定义sex为字符型变量
```

**const类型修饰符**

const类型修饰符必须放在它所修饰的类型名之前，用const修饰的标识符为常量，编译器将其放在**只读存储区**。因此，const常量只能在定义时赋初值，不能在程序中改变其值。
例如： const float pi 3.1415926;

与用#define足义的宏常量相比，const常量的优点如下：

 ①const常量有数据类型，而宏常量没有数据类型。编译器对const常量进行类型检查， 但对宏常量只进行字符串替换，不进行类型检查，字符串替换时极易产生意想不到的错误。
②有些集成化的调试工具可对cost常量进行调试，而不能对宏常量进行调试。

**使用变量时的注意事项**

1.使用变量的基本原则使用变量必须遵循“先定义，后使用”的原则，一条定义语句可以定义若干同类型的变量，其中变量定义的先后顺序无关紧要。C语言要求所有变量必须在第一条可执行语句前定义。
2.注意区分变量名和变量值的概念 变量名标识内存中一个具体的存储单元，变量值则是存储单元中存放的数据。
3.int型变量隐含的修饰类型定义整型变量时，只要不指定为无符号型(unsigned),其隐含的类型就是有符号型(signed)。在实际使用时，signed通常都是省略不写的。
4.用sizeof获得类型或变量的字长（所占存储空间的大小）

注意，sizeof（）是C语言提供的专门用于计算类型字节数的运算符，不是函数。例如，计算int型数据所占内存的字节数用sizeof(int)计算即可。
![CleanShot 2023-03-16 at 16.57.28@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.57.28@2x.png)

**注意实型数据内存存储格式的特殊性**

与整型数据在内存中的存储方式不同，对于实型数据，无论是小数表示形式还是指数表示形式，在内存中都是用浮点方式来实现存储的。

所谓浮点数，是指小数点的位置是可以浮动的数。例如，十进制数1234.56可以写成： 1234.56=0.123456×104=1.23456×103=12345.6×10-1 这里，随着10的指数的变化，小数点的位置也会发生相应的变化。

浮点数与整数在内存中的存储方式是截然不同的，浮点数永远是以如下顺序的位序列存储在内存中的：符号(+或-)，阶码(Exponent),尾数(Significand)。例如，实数N可表示为：

![CleanShot 2023-03-16 at 17.00.01@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.00.01@2x.png)

![CleanShot 2023-03-16 at 17.01.03@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.01.03@2x.png)

![CleanShot 2023-03-16 at 17.01.19@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.01.19@2x.png)

阶码所占的位数决定实数的取值范围；'尾数所占的位数决定实数的精度，尾数的符号决定实数的正负。对于阶码和尾数各自占多少存储空间，标准C并没有明确规定，不同的C编译系统分配给阶码和尾数的存储空间是不同的。显然，这种浮点表示法所能表示实数的取值范围可以远远大于定点表示法，而且也更灵活。

**注意char型数据与int型数据之间的关系**

一个字符型变量中只能存放一个字符。字符串的存储需要用到字符数组，将在第6章中介绍它。字符变量的取值范围取决于计算机系统所使用的字符集。目前，计算机上广泛使用的字符集是ASCII码（美国标准信息交换码）字符集。该字符集规定了每个字符所对应的编码，即在字符序列中的“序号”。也就是说，每个字符都有一个等价的整型值与其相对应。
从这个意义上说，char型可看成一种特殊的整型数。附录D给出了常用字符的ASCII对照表。
一个int型数据在内存中是以二进制形式存储的，而一个字符在内存中也是以其对应的ASCII码的二进制形式存储的。例如，对于字符A',内存中存储的是其ASCII码65的二进制值，存储形式与int型数65类似，只是在内存中所占字节数不同而已。char型数据占1字节，而it型数据在16位编译系统中占2字节，在32位编译系统中占4字节。
因此，在C语言中，只要不超出ASCIⅡ码的取值范围，char型数据和int型数据之间的相互转换就不会丢失信息，这也说明，char型常量可参与任何int型数据的运算。

**注意实型变量数据的舍入误差**
![CleanShot 2023-03-16 at 17.05.22@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.05.22@2x.png)

这是因为浮点数并不是真正意义上的实数，它只是实数在某种范围内的一种近似。事实上，在CPU的内部，所有的浮点数在被浮点指令装入浮点寄存器时都会发生转换，从单精度、双精度、整数转换为扩展精度，当从浮点寄存器存入内存时又会发生转换，从扩展精度转换为相应的精度格式，这种转换是由CPU硬件自动完成的。正是由于从扩展精度转换为低精度格式这一行为的存在，会让程序在进行浮点数赋值或浮点数相等比较时出现奇怪的结果。
当数据从低精度格式转换到高精度格式时，一般而言不会引起精度的丢失，因此，这样的转换相对是安全的，随着表示数据的位数的增加，高精度格式可以把低精度格式的相应数据位复制过来，通常不会丢失任何信息，但long型转换为float型是一个例外，因为当long 型整数的位数超过7位时，转换为float型后，会因f1oat型的有效位数不高于7位而发生数据信息丢失。从高精度向低精度进行转换时，当数值超出低精度数据类型的表数范围时，有可能发生数值溢出，即使数值没有超出低精度数据类型的表数范围，也有可能发生数据信息丢失，因为低精度格式的数据位数比高精度的少，容纳不下高精度的所有信息，这样就会出现舍入(Round),也称截断。

根据EEE标准，处理器可以按4种不同的方式进行舍入： 

(1)舍入到最邻近的数(Round to Even)。如果需要被舍入的数正好在中间，就舍入到最邻近的偶数，舍入后的数有可能大于原数。这是大多数运行环境的默认舍入规则。
(2)对称地朝着0的方向舍入(Round to Zero),舍入后数的绝对值不大于原数的绝对值。
(3)朝着-o的方向向下舍入(Round Down),舍入后的数不大于原数。
(4)朝着∞的方向向上舍入(Round UP),舍入后的数不小于原数。

**注意数值溢出问题**

由于浮点数的表数范围是有限的，因此当数值的量级过大，无法表示为浮点数时，浮点运算就会溢出(Overflow)。与整数不同的是，浮点数不仅存在上溢问题，还存在下溢问题。
“上溢”是指运算结果的绝对值大于计算机能表示的最大数的绝对值，“下溢”是指运算结果的绝对值小于计算机能表示的最小数的绝对值。由于浮点数的精度也是有限的，因此，当进行某些操作时，如果其结果无法在系统可以提供的精度内表示完全，就会造成精度损失，发生“下溢”。精度损失在一次运算中可能并不显著，但是通过累加，损失的精度就有可能扩大。
例如，进行无符号数减法必须要保证被减数大于减数，否则就会发生“下溢”而得到一个比较大的正数。
溢出的危害在于编译器对它熟视无睹，不会帮用户检查这种错误。一个经典的例子就是1996年阿丽亚娜火箭因浮点数转换成整数发生溢出而导致发射失败，可谓“小蛇吞大象”。
避免溢出的一个根本方法就是了解处理问题的规模，尽量准确估算运算结果的可能取值范围，选择取值范围更大的变量类型，不要让变量的值超过该变量类型的取值范围。例如，尽量使用double型而非float型来处理浮点数，如果问题规模很大，可能还要使用long double型。

如本节第5点所述，浮点数在内存中表示为阶码和尾数两部分。阶码所占的位数决定实数的取值范围：尾数所占的位数决定实数的精度。不同的C编译系统分配给阶码和尾数的存储空间是不同的。因此，在不同的系统下，实数的精度是不同的。在Visual C++ 中，float型的有效位只有6~7位，double型的有效位只有15~16位，有效位后面的数字都是不精确的。
浮点数的极限值和有效位数，是在f1oat.h头文件中定义的（整型数的极限值NT MAX 和NTMN是在limits.h头文件中定义的)。例如，宏名DBL MAX和DBL MIN分别表示double型浮点数的上限值和下限值，而DBL DIG则表示其有效位数。通过下面的语句： 

printf("DBL DIG %d\n",DBL DIG); 可以输出double型浮点数的有效位数。

#### 1.2.6 **常用运算符及表达式**



C语言的运算符极其丰富，根据运算符的性质分类，

可分为算术运算符、关系运算符、逻辑运算符、赋值运算符、位运算符等。
也可根据运算所需的对象即操作数(Operand)的个数对运算符进行分类：

只需一个操作数的运算符称为单目运算符（或一元运算符）：

需要两个操作数的运算符称为双目运算符（或元运算符)：

C语言中还有需要三个操作数的特殊运算符，这类运算符称为三目运算符（或三元运算符)。

C语言表达式(Expression)是运算符、常量和变量的任意组合。



**运算符的优先级与结合性**

略



#include <math.h>

![CleanShot 2023-03-16 at 17.22.42@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.22.42@2x.png)

![CleanShot 2023-03-16 at 17.23.49@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.23.49@2x.png)

![CleanShot 2023-03-16 at 17.24.03@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.24.03@2x.png)

![CleanShot 2023-03-16 at 17.24.11@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.24.11@2x.png)

#### 1.7 **赋值运算符**

赋值运算符(Assignment Operator)的含义是将一个数据赋给一个变量，虽然书写形式与数学中的等号相同，但两者的含义是截然不同的。由赋值运算符及相应操作数组成的表达式称为赋值表达式。其一般形式为： 变量名=表达式例如，像a+b=c这样的式子在数学中是合法的，它表示a+b的值与c的值相等，而在C语言中，赋值运算的操作是有方向性的，即将右侧表达式的值（也称为右值）赋给左侧的变量。因此，=号左侧不允许是表达式，只能是标识一个特定存储单元的变量名。在C语言中，a+b=c是错误的。再如，x=x+1在数学中是无意义且永远不成立的式子，而在C语言中是有意义的，它的含义是：取出x的值后加1，然后再存入x中。
由于变量名只能出现在赋值运算符的左边，因此它也被称为左值Ivalue(left value);由于常量只能出现在赋值运算符的右边，因此它也被称为右值value(right value)。左值可以用作右值，但是右值不能用作左值。
赋值运算符的优先级低于算术运算符、关系运算符以及逻辑运算符。由于赋值表达式的值被规定为运算完成后左操作数的值，类型与左操作数相同，且赋值运算符的结合性为右结合，因此，C语言还允许下列赋值形式： 变量1=变量2=变量3=…=变量n=表达式这种形式称为多重赋值表达式，一般用于为多个变量赋予同一个值的场合。由于赋值运算符是右结合的，因此执行时是把表达式值依次赋给变量n,,变量1，即上面的形式等价于变量1=（变量2=（变量3=(=（变量n=表达式）…)) 另外，还有一种特殊形式的赋值运算符，称为复合的赋值运算符(Combined Assignment Operators),其一般形式如下： 变量二元运算符=表达式它等价于变量=变量二元运算符表达式

**增1和减1运算符**

![CleanShot 2023-03-16 at 17.26.51@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.26.51@2x.png)

**位运算符**

![CleanShot 2023-03-16 at 17.57.27@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.57.27@2x.png)

## 2 键盘输入与屏幕输出



## 2.1 语句分类

1. 控制语句。C语言只有如下9种控制语句(Control Statement)。
   1. ![CleanShot 2023-03-17 at 10.12.16@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2010.12.16@2x.png)

2. 变量定义语句。由类型关键字后接变量名（如果有多个变量名，则用逗号分隔）和分号构成的语句，如“int a,b,c:”。
3. 表达式语句。由表达式后接一个分号构成的语句。
4. 函数调用语句。表达式必须是有值的，而函数调用不一定是有返回值的。在C语言中，没有专门的输入/输出语句，输入/输出操作通常是通过调用输入/输出函数来实现的。
5. 复合语句。两条或两条以上的语句序列，用一对花括号括起来构成的语句。
6. 空语句。只有一个分号构成的语句，表示什么也不做。

### 2.2 表达式语句

赋值操作是顺序结构中最常见的操作。但是在C语言中，没有专门的赋值语句， 赋值操作通常是用赋值表达式后接一个分号(；)构成赋值表达式语句实现的。例如，c=a+b 只是一个赋值表达式，而c=a+b://赋值表达式语句则是一个表达式语句。表达式语句与表达式在概念上是完全不同的。

### 2.3 复合语句和空语句

### 2.4 基本的输人/输出操作

#include <stdio.h>

#### 2.4.1字符输入/输出

变量=getchar();

 putchar(变量)；

从这个例子可以得出以下三点结论。
①函数putcharO的作用是向终端显示器屏幕输出一个字符。这个字符可以是可打印字符，也可以是转义序列，函数putcharO的参数就是待输出的字符。
②函数getchar(0的作用是从系统隐含指定的输入设备（即终端键盘）输入一个字符， 按回车键表示输入结束。函数getchar()没有参数，函数的返回值就是从终端键盘读入的字符。
③输出n'的作用是将光标移到下一行的起始位置处。

#### 2.4.2格式输入/输出

1.函数printf(0的一般格式printf(格式控制字符串)；

 printf(格式控制字符串，输出值参数表)； 

格式控制字符串(Format Control String)是用双引号括起来的字符串，也简称为格式字符串(Format String),输出值参数表中可有多个输出值，也可没有（当只输出一个字符串时。
一般，格式控制字符串包括两部分：如表3-l所示的格式转换说明符(Conversion Specifiers) 和需原样输出的普通的文本字符(Literal characters)。

![CleanShot 2023-03-17 at 10.29.40@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2010.29.40@2x.png)

2.函数scanf()的一般格式

![CleanShot 2023-03-17 at 10.31.14@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2010.31.14@2x.png)

参数地址表是由若干变量的地址组成的列表，这些参数之间用逗号分隔。函数scanf(0要求必须指定用来接收数据的变量的地址，每个转换说明符都对应一个存储数据的目标地址。
如果没有指定存储数据的目标地址，虽然编译器不会提示出错信息，但会导致数据无法正确地读入指定的内存单元中。当函数scanf()成功调用时，返回值为成功赋值的数据项数；出错时，则返回EOF(EOF是“End Of File”的缩写词，表示文件结尾，它是一个在头文件<stdio.h> 中定义的整数型的符号常量，C标准只是将EOF定义成一个负整数，通常被定义为-1，但并不一定是-1。因此在不同的系统中，EOF可能取不同的值)。

3.函数printf()中的格式修饰符

在函数printf()的格式说明中，在%和格式符之间的位置，还可插入如表3-3所示的格式修饰符，用于指定输出数据的最小域宽(Field Width)、精度(Precision)、对齐方式等。

![CleanShot 2023-03-17 at 10.32.50@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2010.32.50@2x.png)

这说明，当按照指定的精度打印浮点数时，打印的数值将是小数部分舍入(Rounded) 到指定的小数点后位数的结果，而存储在内存中的浮点数值是不变的。
还可以通过格式控制字符串后面的实参列表中的整型表达式来指定域宽和精度。方法是：在格式控制字符串中域宽或精度的位置上写上一个星号*。这时，程序先计算实参列表中对应的整型表达式的值，然后用其替换星号。例如，下面这条语句： printf("号*.*f",7,2,100.15799); 将以7为域宽，2为精度，输出右对齐的100.16。

4.函数scanf()中的格式修饰符

![CleanShot 2023-03-17 at 10.35.17@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2010.35.17@2x.png)

![CleanShot 2023-03-17 at 10.35.46@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2010.35.46@2x.png)

显然，这个程序和例3.10一样，问题也是出在%c格式符上面，输入12以后按的回车键被当作有效字符读给字符型变量b了。解决这个问题有如下两种方法。

方法1 用函数getchar()将前面数据输入时存于缓冲区中的回车符读入，避免被后面的字符型变量作为有效字符读入。

方法2在%c前面加一个空格，将前面数据输入时存于缓冲区中的回车符读入，避免被后面的字符型变量作为有效字符读入。就程序可读性而言，这个方法更好一些。

3. 对输入非数字字符的检查与错误处理

   由于scanf()不进行参数类型匹配检查，因此，当输入数据类型与格式字符不匹配时，编译器不提示出错信息，但会导致程序不能正确读入数据。即使输入数据类型与格式字符相符， 也无法保证用户输入的数据都是合法的数据，一旦输入非法数据，也会导致数据不能正确读入。来看下面的程序。

## 3、程序的控制结构

### 3.1 算法及其描述方法

数据结构+算法=程序

计算机解题的算法大致分为如下两类。
(1)数值运算算法。主要用于解决求数值解的问题，如二分法求方程的根，梯形法计算定积分等。
(2)非数值运算算法。主要用于解决需要用分析推理、逻辑推理才能解决的问题。例如， 分类、查找等。
那么设计一个算法后，怎样衡量它的正确性呢？一般，可用如下特性来衡量。
①有穷性。算法包含的操作步骤应是有限的，每个步骤都应在合理的时间内完成。
②确定性。算法的每个步骤都应是确定的，不能有歧义。例如，“若x≥0，则输出Ys: 若x≤0，则输出No”,当x等于0时，既输出Ys,又输出No,就产生了不确定性。
③有效性。算法的每个步骤都应是能有效执行的，且能得到确定的结果。例如，对一个负数取对数，就是不能有效执行的步骤。
④没有输入或有多个输入。有些算法不需从外界输入数据，如计算5！：而有些算法则需要输入数据，如计算n!,n的值是未知的，执行时需要从键盘输入n的值后再计算。
⑤有一个或多个输出。算法的实现以得到计算结果为目的，没有任何输出的算法是没有任何意义的。

#### 3.1.2算法的描述方法

1.自然语言描

2.流程图描述

3.NS结构化流程图描述

4.伪码描述

### 3.2顺序结构

1. 输入算法所需要的数据
2. 进行运算和数据处理。
3. 输出运算结果数据



![CleanShot 2023-03-17 at 11.25.09@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2011.25.09@2x.png)

对照上面的结构框架可知，程序的第1行include<math.h>是一种编译预处理命令，它指示编译系统在对源程序编译之前对源代码进行某种预处理操作，包括宏定义、文件包含、条件编译等。所有的编译预处理命令都以#开始，每条指令单独占一行，同一行不能有其他的编译指令和C语句（注释除外）。注意，编译预处理命令不是C语句，前面第2章介绍的宏定义，也是一种编译预处理命令。这里，include表示它是文件包含编译预处理命令。
文件包含编译预处理命令#include指示编译系统将一个源文件嵌入含有#include指令的源文件中该指令所在的位置处。为什么要使用文件包含编译预处理命令呢？ 因为在C程序开发系统中，无论哪种版本，也无论在哪类操作系统上实现，一般都提供庞大的支持库。C库可分为两类：一类是函数库，另一类是扩展名为的头文件库。`函数库中包含C提供的标准函数的目标代码，供用户在程序中调用。
通常，在程序中调用一个库函数时，要在调用前引用该函数原型所在的头文件。例如， 调用函数scanf(0、printfO)等有关输入/输出的函数时，需要引用标准输入/输出头文件stdio.h; 调用标准数学函数时，要引用数学头文件math.h,等等。
头文件中包含常量定义、类型定义、宏定义、函数原型以及针对编译命令中的选择项设置的选择开关等一系列声明信息，供用户直接引用，引用头文件的结果是，编译程序时将包含的文件插在引用的位置。例如，#include<math.h>的作用是在编译程序时将文件math.h插入当前被编译文件引用位置处并一起编译，因为本程序中要使用math.h中定义的标准数学函数，所以必须在程序开头使用#include<math.h>编译预处理命令。
当然，include命令还可用于包含用户自己创建的头文件。以多文件方式组织的程序常常需要在各文件之间共享一些类型声明、外部声明、常量定义等，这些信息可放在程序员自己创建的头文件中，然后用#include编译预处理命令将其包含到需要使用这些信息的程序中。

一般，对于系统提供的头文件，通常采用尖括号括起来的形式，即#include<文件名> 对于用尖括号括起来的头文件，C编译器直接到系统的NCLUDE子目录中去寻找尖括号内文件名所指定的头文件，然后将文件内容包含到这个命令所在的文件中。
对于用户自己创建的头文件，通常使用双引号括起来的形式，即#include"文件名" 对于用双引号括起来的头文件，C编译器首先搜索当前子目录，如果找不到文件名所指定的文件，再去搜索C的系统子目录。
用这样两种形式区分被包含的头文件，主要目的是为了减少编译器搜索指定文件的时间，从而加快编译速度。



### 3.3选择结构

略，比较简单，可以看一下流程图的制作后面

#### 3.3.4开关语句

![CleanShot 2023-03-17 at 13.52.40@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2013.52.40@2x.png)

### 3.4循环结构

循环结构有两种类型：

 ①当型循环结构（如图4-15所示），表示当条件P成立（为真)时，反复执行A操作， 直到条件P不成立（为假），时结束循环。
②直到型循环结构（如图4-16所示），表示先执行A操作，再判断条件P是否成立（为真)，若条件P成立（为真），则反复执行A操作，直到条件P不成立（为假)时结束循环。

![CleanShot 2023-03-17 at 13.57.25@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2013.57.25@2x.png)



#### 3.4.3循环语句

![CleanShot 2023-03-17 at 13.58.16@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2013.58.16@2x.png)

### 3.5流程转移控制语句

#### 3.5.1 goto语句

![CleanShot 2023-03-17 at 14.19.21@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2014.19.21@2x.png)



#### 3.5.2 break与continue语句

![CleanShot 2023-03-17 at 14.20.11@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2014.20.11@2x.png)

结构化程序设计的基本思想归纳起来有以下三点。
①采用顺序、选择和循环三种基本控制结构作为程序设计的基本单元。用这三种基本控制结构编写的程序具有如下4个特性： ·只有一个入口。
●只有一个出口。	
●无死语句，即不存在永远都执行不到的语句。
●无死循环，即不存在永远都执行不完的循环。

②结构化程序设计认为，goo语句是有害的，理由是goto语句可以不受限制地转向程序中（同一函数内）的任何地方，使程序流程随意转向，从而破坏了结构化程序要求的“单进单出”结构。一旦使用不当，将导致编写的程序流程混乱不堪，影响程序的可读性。
不过，导致程序流程混乱、不易阅读的真正原因其实并不在于使用较多的g0o语句，而在于使用了较多的goto语句标号。例如，在程序的多个地方，用g0to语句转向同一语句标号处，进行相同的错误处理，这种做法不但不会影响程序结构的清晰，相反还会使程序变得更加简洁。
因此，结构化程序设计规定，尽量不要使用多于一个的g0o语句标号，同时只允许在一个“单进单出”结构内用goto语句向前跳转，不允许往回跳转。

③采用“自顶向下、逐步求精”和模块化方法进行结构化程序设计。

因此，逐步求精技术可以理解为是一种由不断的自底向上修正所补充的自顶向下的程序设计方法。它有以下两个优点：

①用逐步求精方法最终得到的程序是有良好结构的程序，它具有结构清晰、容易阅读、容易修改的特点。整个程序由一些相对较小的程序子结构组成，每个子结构都有一定的相对独立的意义，改变某些子问题的策略相当于改变相应的局部结构的内部算法，不会影响程序的全局结构。
②用逐步求精方法设计程序，可以简化程序的正确性验证。结合逐步求精过程，采取边设计边验证的方法，逐级验证相比整个程序写完后再验证，大大减少了程序调试的时间和复杂度。

逐步求精实现技术有以下三种方法。
(1)“划分与解决”的分割技术（序列技术) 这种技术是指将问题分成若干可以顺序处理的子问题。
第1步把问题划分成一些不相交的部分，直到可以用复合语句表示为止。
第2步依次解决划分后的每步问题。例如，数据处理中的许多问题都可划分成读入已知数居、计算处理数据和打印输出结果三部分。
(2)“做出有限进展”的递推技术（循环技术） 这种技术是指如果找到了一个朝向问题最终解的方向，那么就做出有限进展，重复使用递推，直到使它达到最终解。例如，求6！=5！×6,5！=4！×5，…，其余类推，直至得到最终解。
(3)“分析情况”的分析技术（分支技术） 这种技术是指对问题按不同情况分析使之精细化，直到可用条件语句实现为止。
总而言之，用逐步求精技术求解问题的大致步骤如下： ①对实际问题进行全局性分析、决策，确定数学模型。
②确定程序的总体结构，将整个问题分解成若干相对独立的子问题。



## 4、函数

### 4.2 函数的定义与使用

#### 4.2.1函数的分类

1.库函数

ANSI C的编译器，不管它支持什么平台，都必须提供这些函数供用户使用。仅调用ANSI C 库函数的程序，具有很好的移植性，可以在多种平台上编译运行。
还有数量巨大的第三方函数库，完成ANSI C中不包含而程序设计者又需要的功能。例如无大小限制的数值计算、微积分运算、网络、数据库和图形界面等。有的库可以免费获得和使用，有的则需要购买。
使用ANSI C的库函数时，只要在程序开头把该函数所在的头文件包含进来即可。例如， 用sinO函数前，通过查联机帮助或用户手册得知，该函数在math.h内定义，则在程序里加上： #include <math.h> 只要编译器的配置正确，便可直接使用math.h内定义的所有库函数。使用第三方库函数时，除要包含头文件外，往往还需要一些额外配置。具体情况因库和编译器而异，请查阅相关文档。

2.自定义函数

用户可按自己的意愿编写完成任意功能的函数。把相关函数集合到一起，就构成了你自己的函数库。如果这个库真的很好用，
本章重点集中于常用库函数和自定义函数。

#### 4.2.2函数的定义

![CleanShot 2023-03-17 at 14.28.44@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2014.28.44@2x.png)

#### 4.2.3 函数的调用、参数传递和返回值

实参的数量必须与形参相等，它们的类型必须匹配（匹配的原则与变量赋值的原则一致)。形参相当于在函数内定义的变量，也可以被赋值。实参与形参有各自的存储空间，所以形参值的改变不会影响实参。
一个函数可定义的形参并无明确的数量限制，用户可以按照需要随意定义。不过一个良好风格的程序里是不会有含过多参数的函数出现的。那样的函数过于复杂，难以理解，用起来也不方便。如果确实有大量数据需要传递，可以采用第6章和第7章将讲述的数组与指针。

例5.1和例5.2两种写法功能上完全等价，形式上的区别是，例5.1里函数Max0的定义在前，而例5.2里函数main0的定义在前。
在例5.1中，MaxO先定义，编译器在编译main(的时候便知道Max0有哪些参数，返回值类型是什么，从而可以正确编译。在例5.2中，如果没有前面一行对函数Mx0原型的声明， 编译到main0时就会不知道MaxO是什么样子。
除了末尾的分号外，函数原型(Function Prototype)声明的语法格式与函数定义的首部完全一致。
函数如果不先定义或声明，也能使用，但运行结果可能不确定（这也是C89不严密的一个地方，C99对此有严格规定)，所以一定要先定义或声明。
stdio.h和math.h等头文件的内容主要就是各个库函数的原型声明，和这里介绍的语法及功能一致。读者可以到编译器的include目录下自行打开查看。

#### 4.2.5 主函数main()的特殊性

尽管main函数也有返回值，但是有时在定义mainO时，可以不指明其返回值类型，没有参数也可以不用vod。这种用法是符合C语言语法的，任何函数也都可以如此定义。从表面上看，这样定义的函数似乎没有返回值和参数；但实际上它的默认返回值是it类型，并且有任意数量的int型参数。

### 4.3 变量的作用域和存储类型

#### 4.3.1变量的作用域

每个语句块的头部都可以定义变量。变量的作用域(Scope)规则是：每个变量仅在定义它的语句块（包含下级语句块）内有效，并且拥有自己的内存空间。

同一个语句块内不可以定义同名变量，不同语句块内可以定义同名变量。两个毫不相干的语句块定义的同名变量自然也毫不相干，各司其职。如果两个嵌套的语句块定义了同名变量，在高级别语句块自然只有一个变量有效，而在低级别语句块，那么，按照作用域规则， 两个变量都有效。对这种冲突怎么办？

#### 4.3.2全局变量

假如把整个程序看作一个大语句块，按照变量作用域规则，在与main()平行的位置，即不在任何语句块内定义的变量在程序的所有位置均有效。这就是全局变量(Global Variable)。
相对而言，在其他语句块内定义的变量被称为局部变量(Local Variable)。
全局变量从程序运行起即占据内存，在程序整个运行过程中可随时访问，程序退出时释放内存。与之对应的局部变量在进入语句块时获得内存，仅能由语句块内的语句访问，退出语句块时释放内存，不再有效。
局部变量在定义时不会自动初始化，除非程序员指定初值。**全局变量在程序员不指定初值的情况下自动初始化为零。**

### 4.3.3变量的存储类型

**1.自动变量(Automatic Variable)**

自动申请内存，退出时自动释放内存。其标准定义格式为： 

auto 类型名 变量名；

例如： auto int a,b,c =0; 这种变量实在太常用，无处不在，于是C语言很贴心地把uto设计成完全可以省略，所以它成为使用最少的关键字。

**2.寄存器变量(Register Variable)**
register类型名变量名；

请不要认为把所有变量都定义为register程序就会变快。因为寄存器只有很有限的几个， 轮不上的，编译器自动处理成普通变量。也不要认为只定义一个寄存器变量它就肯定成功， 编译器有权以任何理由阻止任何变量成为register。最后，请不要认为你定义的普通变量肯定不会是register,编译器有权以任何理由让它成为寄存器变量。
这很混乱吗？不，很简单。现在的编译器都特别聪明，能自动优化程序。它知道什么时候把哪个变量放到寄存器里速度会最快，完全不需要用户操心。因此，register是一个不再需要的关键字。

**3.静态变量(Static Variable)**

被static关键字定义的变量称为静态变量。它仍然仅在语句块内有效，但其空间自第一次进入语句块时分配且初始化后，一直到程序完全退出才释放，所以其值始终保持。

### 4.4函数封装

### 4.5预处理指令

在第1章中，我们介绍了从源代码到执行文件的转换过程是“编译”，做这件工作的程序被称为“编译器”。把编译的过程更加细分一下，是“预处理”、“编译”和“链接”三个步骤。
“编译”做的工作是把源代码翻译为机器代码，然后由“链接”将机器代码组合为执行文件。链接的细节稍后介绍。“预处理”在编译之前进行，根据源代码中的预处理指令，在后台调整源代码。编译器编译的都是经过预处理的代码。
预处理指令的典型特色是以“#”开头。我们熟悉的#include和#define都是预处理指令。
还有很多我们尚未谋面的预处理指令，它们都是C语言不可缺少的一部分。

#### 4.5.1 #include

#include被称为源代码包含指令，简称包含指令。

它有两种用法： #include <filename> #include "filepath"

“<>”和双引号表示定位filename文件的两种不同方式。前者是在编译器指定的目录（也可以由用户通过设置编译器选项指定这个目录)内查找filename文件，它通常就是一个叫“include”的目录，目录下有很多h文件，包括我们熟悉的stdio.h、math.h等。你可以在硬盘中找到并打开它们，看看整日被你包含的文件，内里究竟是何等乾坤。后者是按照filepath 所描述的路径查找文件。通常我们给定的filepath里并不含有路径，只是一个文件名，表示在与源文件相同的目录下查找filepath。
如果能成功定位文件（否则会出现编译错误），则预处理器会用该文件的内容替换#include 指令所在的行。替换后的代码再被编译器编译。例如同一目录下有两个文件，foo.h和foo.c,

#### 4.5.2 #define和#undef

#define叫宏定义指令。最惯常的用法我们都很熟悉：

 #define MACRO I NAME replacement

宏的有效范围是从定义它的那一行开始，直至遇到种undef为止。如果没有undef,就一直作用到文件末尾。

undef的功能从名字就可看出，是取消宏定义，语法如下： #undef MACRO NAME 宏被取消后可以重新定义，并且仅在被取消后才能重新定义。

#### 4.5.3条件编译

预处理指令还有剪裁代码的能力，使某些代码仅在特定的条件成立时才会被编译进可执行文件。这项功能由if、#ifdef、#ifndef、else、#elif和#endif组合实现。例如，下面的代码：

```
//
// Created by kuiqwang on 2023/3/16.
//

#include <stdio.h>
#define  TAG 1
#if TAG
int a;
int b;
#else
long a;
long b;
#endif

int main(void){
    printf("%d\n", sizeof(a));
    printf("%d", sizeof(b));

}
```

### 4.7模块和链接

略



## 5、数组

#### 5.2 数组的定义、引用和初始化

与基本类型变量的使用方法一样，数组作为带有下标(Subscript)的变量，也应遵循“先定义，后使用”的原则。数组定义的一般形式为：

![CleanShot 2023-03-17 at 15.37.09@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2015.37.09@2x.png)

![CleanShot 2023-03-17 at 15.37.57@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2015.37.57@2x.png)

![CleanShot 2023-03-17 at 15.38.26@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2015.38.26@2x.png)

必须指定数组元素的类型和数组元素的个数，这样编译器才能为数组预留出相应大小的存储空间。

#### 5.2.2数组的引用

![CleanShot 2023-03-17 at 15.42.11@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2015.42.11@2x.png)

#### 5.2.3 数组的初始化

![CleanShot 2023-03-17 at 15.45.22@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2015.45.22@2x.png)

初始化列表中提供的初值个数不能多于数组元素的个数，但可少于数组元素的个数。当初始化列表中提供的初值个数少于数组元素的个数时，系统将自动给后面的元素赋初值0，

注意，当给数组部分元素赋初值时，对数组的长度声明不能省略。
此外，当数组被声明为静态（static)存储类型或外部存储类型（即在所有函数外部定义）

由于数组元素的初始化是在程序运行前（即编译时)执行的，因此在不显式给出初值的情况下，数组元素将被自动初始化为0。例如： static short a[5]; 等价于static short a[5]=(0,0,0,0,0}; 而自动类型的数组的初始化是在程序运行时执行的。



### 5.3向函数传递一维数组

```
//
// Created by kuiqwang on 2023/3/16.
//

#include <stdio.h>

#define  TAG 1
#if TAG
int a;
int b;
#else
long a;
long b;
#endif

//形参，地址
void add(int a[]) {

    printf("%d", a);
}

int main(void) {
    int a[] = {1};
    printf("%d\n", a);//名称代表数组首元素地址
    add(a);
}
```

本节介绍了向函数传递一维数组的方法，用数组名作为函数参数时，需要注意以下两点：

 ①C语言中，所有实参都是单向传值的。简单变量用作函数实参传递的是变量的值，是按值传参，是将实参的值复制给形参，因此，形参值的改变不会影响实参。而数组名用作函数实参传递的是数组在内存中的起始地址，是模拟按引用传参，是将实参代表的地址值复制给形参，其结果是形参和实参都指向了内存中同一段连续的存储单元。就像房主配了一把房间的钥匙给房客一样，房客也具有了修改房间内容的权限。因此，若在被调函数中改变形参数组的元素值，则实参数组中的元素值也会随之发生改变。这种改变不是形参向实参反向传值造成的(C语言不允许这种反向的值传递)，而是由于形参和实参两个数组在内存中指向同地址而共享同一段内存造成的。可见，虽然模拟按引用传参比按值传参更高效，但安全性不如按值传参好。

②对一维形参数组进行类型声明时，在方括号内可以给出数组的长度声明，即将其定义为固定长度数组：也可以不给出数组的长度声明，将其定义为可变长度数组。这时，一般用另一个整型参数来指定数组长度。注意，这种方法仅在一维数组作为形式参数时才能使用。

#### 5.4 向函数传递二维数组

同样，用二维数组的数组名作为函数实参，向被调函数传递数组的起始地址，可以避免向函数复制全部数组元素所需的开销。与函数形参被声明为一维数组时所不同的是，当形参被声明为二维数组时，不能省略数组第二维的长度，仅可以省略数组第一维的长度。因为C 编译器必须已知每列的长度，才能对二维数组元素进行正确的寻址操作，否则编译器无法确定第二行的数组元素从哪里开始存取。例如，假设定义了一个4行3列的二维数组，则接收这个二维数组的函数Fu(假设该函数没有返回值)可以定义成：

![CleanShot 2023-03-17 at 16.12.02@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.12.02@2x.png)

### 5.5字符数组

#### 5.5.1 字符数组与字符串的关系

字符串(Character String)是由若干有效字符构成且以字符"\0'作为结束标志的一个字符序列。字符串常量是用一对双引号括起来的一串字符，如"China'"。其中，'\0'作为字符串的结束标志，在这里可不显式写出，C编译程序自动在其尾部添加字符'\0'。

将字符串赋值给字符数组有如下两种方法1.用字符型数据对数组进行初始化

![CleanShot 2023-03-17 at 16.23.07@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.23.07@2x.png)

字符数组sr有6个元素，但其存储的字符串长度为5，这是因为字符串结束标志0'也占用1字节的内存，但它不计入字符串的实际长度。因此，在定义字符数组长度时，除了要考虑字符串中的实际字符个数外，还必须多留出1字节的存储单元，以便存放0'。

![CleanShot 2023-03-17 at 16.26.29@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.26.29@2x.png)

系统默认的s2数组长度为5。由于初始化列表的末尾没有字符串结束标志"0'，也没有多余的空间供系统自动添加字符串结束标志"0'，因此，这时定义的st2仅仅是一个长度为5的字符数组，不能把它当作字符串来使用。由此可见，一个字符型一维数组并不一定是一个字符串，只有当字符型一维数组中的最后一个元素值为0时，它才构成字符串。所以，按上面这种方式给字符数组赋初值时，必须人为地加入0'，才能将其作为字符串来使用。

2.用字符串常量直接对数组初始化

![CleanShot 2023-03-17 at 16.27.31@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.27.31@2x.png)

![CleanShot 2023-03-17 at 16.28.26@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.28.26@2x.png)

#### 5.5.2 字符数组的输入/输出

(1)按c格式符一个字符一个字符地单独输入/输出

![CleanShot 2023-03-17 at 16.51.30@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.51.30@2x.png)

![CleanShot 2023-03-17 at 16.51.54@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2016.51.54@2x.png)

(2)按s格式符将字符串作为一个整体输入/输出

用函数scanf()按s格式符输入一个字符串时，必须注意以下三点： ①因为字符数组名本身代表该数组存放的字符串的首地址，所以用scaf语句的%s格式输入字符串时，字符数组名的前面不能再加取地址运算符，其后也不需用方括号指出数组元素的下标。
②因为要在保存到字符数组中的字符串末尾添加一个字符串结束标志，所以在定义字符数组的大小时，要为字符串结束符预留出1字节的存储单元，定义的字符数组的大小要比实际存储的字符串的长度大1字节。当然，在用户输入字符串时，也要确保输入的字符串长度不超过数组所能容纳的字符串的长度，否则将会出现缓冲区溢出。
③因为scanf0函数不断地接收用户从键盘输入的字符，并将其保存到字符数组中，直到接收到的字符是一个空格、回车换行符、制表符(Tab)或文件结束符EOF(End-Of-File) 为止，所以空格、回车换行符或制表符(Tab)作为按%s格式输入字符串的分隔符，不能被读入，在输入中遇到这些空白字符时，系统认为字符串输入结束。

(3)用字符串处理函数gets()或puts()输入/输出一个字符串

函数gts()和puts())是C语言提供的标准输入/输出函数。

因此，在使用这两个函数时， 应在程序的开头处加上文件包含编译预处理命令： #include <stdio.h>

注意：当函数scanf()按%d输入数字或按%s输入字符串时，忽略空格、换行符或制表符等空白字符。当读到这些字符时，系统认为读入结束，因此scanf()不能输入带空格的字符串。函数gts0将空格和制表符都视为字符串的一部分，因此允许输入带空格的字符串。此外， 这两个函数在输入字符串时对换行符的处理也是不同的，用函数gts0输入字符串时，空格和制表符都是字符串的一部分，同时将换行符从缓冲区读走，但换行符不作为字符串的一部分，而作为字符串的终止符。scaf0在读取一个字符串时不读走换行符，换行符仍留在缓冲区中，所以在其后再输入字符型数据时，须先使用getchar()或scanf("")将留在缓冲区中的换行符读走。

#### 5.5.3 字符串处理函数

![CleanShot 2023-03-17 at 17.06.33@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2017.06.33@2x.png)

![CleanShot 2023-03-17 at 17.07.10@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2017.07.10@2x.png)

## 6、指针

#### 6.1.1指针的概念

1.什么是变量的地址，什么是变量的值

2.什么是直接寻址，什么是间接寻址

如果变量的值已经存储于内存中，那么如何使用它呢？对变量的访问有两种方式：直接寻址和间接寻址。直接寻址(Direct Addressing),顾名思义，就是直接访问变量的值，使用变量名或使用变量的地址都可直接引用变量的值。

```
short int a =10;
```

由于程序运行时变量a被初始化为l0,因此变量a的当前值是10，也可用变量名a表示变量的值。这种直接按变量名来存取变量值的访问方式，最常见，也最简单。而用地址访问就必须知道变量的地址，需要使用取地址运算符(Address Operator)&来获取变量的地址。

例如，我们可以用&a表示变量a在内存中所占存储单元的首地址，而无须关心该地址的具体值是多少。如果通过p=&a赋值操作，将变量a的地址赋值给另一个变量p,那么我们就获得了另外一种访问变量a的方法，即通过先访问变量p获得变量a的地址值，然后再到该地址值代表的存储单元中去访问变量a。当然，这里的变量p不是普通类型的变量，它是一种特殊类型的变量，即指针类型的变量，简称为指针变量。

指针变量是C语言中专门用于存放地址型数据的变量。如图7-2所示，这种通过指针变量间接存取它所指向的变量值的访问方式，称为间接寻址(Indirect Addressing)。间接寻址就是通过其他变量来获取要访问变量的地址，再进行访问。

![CleanShot 2023-03-17 at 17.11.41@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-17%20at%2017.11.41@2x.png)

3.如何通过指针变量访问它所指向的变量的值

C语言提供了两个单目运算符&和*，使用它们可以方便地实现有关地址和指针的运算。
取地址运算符&用于得到变量的地址。例如，在前面的例子中，&a就代表取变量a的地址，下面语句将a的地址值赋值给指针变量p: P=&a;

为了得到一个指针所指对象的内容，可以用*运算符放在指针变量前以实现通过指针变量间接访问它所指向的存储单元的目的，*称为指针运算符(Pointer Operator)),也称为间接寻址运算符(Indirection Operator)或解引用运算符(Dereference Operator),它返回其操作数(即一个指针)所指向的对象的值。

#### 6.1.2 为什么引入指针的概念

指针之所以重要，原因主要有以下4点：

 ①指针为函数提供修改变量值的手段。
2 指针为C语言的内存动态分配系统提供支持。
3 指针为动态数据结构（如链表、队列、二叉树等）提供支持。
④指针可以改善某些子程序的效率

#### 6.1.3 指针变量作为函数参数

1.如何定义指向某一变量的指针

为了在一个变量中存放另一个变量的地址，·这个变量必须定义为指针类型的变量。与其他类型变量一样，指针变量也要遵循“先定义，后使用”的原则，定义指针变量的一般形式为： 类型关键字*变量名；

其中，变量名前面的*是指针类型说明符，表示这里定义的是一个指针类型的变量，最前面的类型关键字用于指定该指针变量可以指向哪一种类型的变量，或者说用哪一种类型的变量的地址对其进行初始化，我们称其为指针的基类型。例如，下面语句定义了两个可以指向整型数据的指针变量pl和p2(也可以简单地称pl和p2是int型指针)。

其中，变量名前面的*是指针类型说明符，表示这里定义的是一个指针类型的变量，最前面的类型关键字用于指定该指针变量可以指向哪一种类型的变量，或者说用哪一种类型的变量的地址对其进行初始化，我们称其为指针的基类型。例如，下面语句定义了两个可以指向整型数据的指针变量pl和p2(也可以简单地称pl和p2是int型指针)

2.指针变量的特点

①指针变量的内容不能是变量的值，只能是变量的地址，而且必须用相同基类型的变量的地址对指针变量进行赋值。

②指针变量必须初始化后才能使用，不要使用未初始化的指针(Uninitialized Pointer),否则指针所指向的存储单元是未知和不确定的。使用未初始化的指针是一个非常亚重的错误

指针变量的初始化可以在定义指针时进行，也可以通过一条赋值语句来完成。如果在定义指针变量时不能确定指针变量究竟指向哪里，那么可以将指针初始化为NULL。值为NULL 的指针表示它不指向任何对象。NULL是一个在头文件<stdio.>（以及其他头文件，如<stddef..h>)中定义的符号常量，其值通常被定义为0，此时将指针初始化为0等价于初始化为NULL,但是初始化为NULL更好，因为这样显式强调了该变量是一个指针变量。注意， 0是可以直接赋值给指针变量的唯一整数值。

③由于指针变量的值是一个地址值，指针运算实质上就是对地址值的运算，因此指针只能参与赋值运算、算术运算和关系运算，并且指针可以参与的算术运算只有有限的两种： 加和减，即加、减一个整数或增1、减1运算。

④指针算术运算的规则不同于一般的算术运算，指针每次增1，并非存储地址值简单地增加1字节，具体增加几字节取决于指针所指向的变量的类型（即指针的基类型)。
若指针的基类型是字符型，则指针变量的增1运算相当于指针的值增加1字节：若基类型是整型，则指针变量的增1运算相当于指针的值增加sizeof(int)字节。一般而言，指针作为操作数加上或减去一个整数n,其指针值的变化为：加上或减去n*sizeof(基类型)字节。

a =*p; *P=*P+1: 其含义为：先取出变量p所指向的单元中的内容赋值给a,再使p所指向的单元中的内容加1。注意：这里是p所指向的存储单元中的内容发生了变化，而指针变量p的指向并未发生改变。
指针的算术运算和关系运算通常用于与数组有关的程序设计中。对指向数组元素的指针变量执行增1（或减1)运算，意味着指向下一个（或者前一个）数组元素。同理，对指向同一个数组中的不同元素的两个具有相同基类型的指针变量进行关系运算，也才是有意义的， 它实际上是对它们所指向的数组元素在内存中的前后位置关系进行比较。

3.指针变量作为函数参数时，如何得到经被调函数修改的数据值

### # 6.1.4 字符指针作为函数参数

略

### 6.2 指针和数组间的关系

首先，指针的算术运算和关系运算常常是针对数组中元素而言的。由于数组在内存中是连续存放的，因此指向同一数组中不同元素的两个指针的关系运算常用于比较它们所指元素在数组中的前后位置关系。指针的算术运算则常用于移动指针的指向，使其指向数组中的其他元素。当然，仅当指针的算术运算结果仍指向同一数组中的元素时才有意义。

其次，指针和数组的关系还表现在：在表达式中，数组名被自动转化为指向数组中第一个元素的常量指针（除用作sizeof运算的操作数外）。

再次，数组的下标运算符们实际上是以一个指针作为其操作数的。例如，数组元素[门被编译器解释为表达式*(+i),表示从数组首地址开始向后移动i个元素并取出其内容，而&a[表示取数组a的第i+1个元素的地址，它等价于指针表达式a+i。因此，数组元素可以通过指针来引用，指针也可以用下标形式来表示。可用数组实现的操作也可用指针来实现。只是指针实现较数组实现效率高，而数组实现方法更易理解。下面具体针对一维数组和二维数组来分别讲述数组与指针之间的关系。

#### 6.2.1一维数组的地址和指针

1.什么是一维数组的指针，以及一维数组元素的指针

由于数组元素在内存中是连续存放的，即在内存中占用一段连续的存储单元，每个数组元素占用其中的一个存储单元，因此，数组元素实质上就是一个变量，数组元素的指针就是该元素在内存中所占存储单元的首地址，而一维数组的指针就是数组中各元素所占连续存储单元的起始地址，即第一个（下标为0）元素的指针。

2.如何通过一维数组的指针来引用一维数组元素

既然数组名a代表数组的首地址（即&a[0]),那么表达式a+1就表示首地址后下一个元素的地址，即&a[l]。由此可知，表达式a+i代表数组中下标为i的元素a[的地址（&a[))。
不仅可以通过下标方式来引用数组中的元素，还可以通过使用间接寻址运算符*来引用数组中的元素。例如，*a表示取出首地址a所指存储单元中的内容，即元素a[0],*(a+i)表示取出首地址元素后面第i个元素的内容，即下标为i的元素a[。
此外，还可以通过指向一维数组的指针变量p来引用数组a中的元素，如图7-10所示。
当指针变量p指向数组的首地址&a[0]时，*p就表示取出p所指单元即元素a[O]的值， 此时，由于p+i代表当前指针所指元素后面的第i个元素的地址，因此*(p+)表示取出p+i所指向的存储单元的内容，即元素a[门的值。*(p+i)也可用它的下标形式p[)来表示。



#### 6.2.2 二维数组的地址和指针

1.什么是二维数组的行地址和列地址

元素的值，即a[j]。因此，以下4种表示元素a[[]的形式是等价的：



在定义和使用二维数组的行指针时，必须在变量定义语句中指定其所指一维数组的长度(即二维数组的列数)，且不能用变量指定列数。对该行指针执行增1或减1操作时，指针是沿着二维数组逻辑行的方向移动的，每次操作移动的字节数为：二维数组的列数×数组的基类型所占的字节数。显然，如果不指定列数，则编译器无法计算指针移动的字节数。

在定义二维数组的列指针时，无须在变量定义语句中指定二维数组的列数。因为对该行指针执行增1或减1操作时，指针是沿着二维数组逻辑列的方向移动的，每次移动的字节数为：二维数组的基类型所占的字节数。由于它与二维数组的列数无关，因此即使不指定列数， 也能计算指针移动的字节数。此时，相当于将二维数组等同于一维数组看待了。在使用列指针访问数组元素时，因为二维数组的列数只用来计算地址偏移量，所以在计算地址偏移量的表达式中可以用变量表示列数。由于无须在声明二维数组的列指针时指定二维数组的列数， 因此二维数组的列指针常用作为函数参数，以实现二维数组的行列数需要用变量动态指定的场合。

###  6.3指针数组

指针不仅可用于指向一个数组，还可作为数组的元素，形成指针数组。由若干基类型相同的指针所构成的数组，称为指针数组（Array of Pointers)。由定义可知，指针数组的每个元素都是一个指针，且这些指针指向相同数据类型的变量。指针数组定义的一般形式为：

 类型关键字*数组名[常量N]： 其中，常量N规定了指针数组的长度，类型关键字代表指针数组元素可指向的数据类型。

### 6.4函数指针

略

### 6.5带参数的main0函数

### 6.6  动态数组的实现

#### 6.6.1 C程序的内存映像



综上所述，C程序中变量的内存分配方式有以下三种。

①从静态存储区分配。程序的全局变量和静态图7-19C程序的内存映像变量都在静态存储区上分配，且在程序编译时就已经分配好了，在程序运行期间都是存在的。只有在程序终止前，才被操作系统收回。
②在栈上分配。在执行函数调用时，函数内的局部变量及形参都是在栈上分配的，该函数执行结束时，这些内存自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是容量有限。
③在堆上分配。在程序运行期间，用动态内存分配函数来申请的内存都是在堆上分配的。动态内存的生存期由程序员自己来决定，使用非常灵活，但也最容易出现问题。有一点需要程序员时刻牢记：在不用这些内存的时候，一定用free()将其释放，以防止内存泄漏的发生。千万不可因程序结束自然会释放所有内存而存在侥幸心理，如果这段程序被用于一个需要连续运行数月的商业软件，那么不释放内存的后果将不堪设想。

#### 6.6.2 动态内存分配函数

全局变量分配在全局变量存储区，非静态的局部变量（包括自动变量和形参）使用栈空间为其分配存储单元，而动态内存分配函数则从称为“堆”的自由内存区取得内存。

ANSI C标准定义了4个动态分配函数：malloc()、calloc0、free(0和realloc()。利用这几个动态内存分配函数可以随时分配和释放存储空间。ANSI C规定，使用这些函数时，要用#include命令将stdlib.h文件包含进来。下面介绍这几个动态分配函数。

1.函数malloc()

函数malloc（）用于分配若干字节的内存空间，返回一个指向该存储区地址的指针。若系统不能提供足够的内存单元，函数将返回空指针(NULL),NULL是在stdio.h中定义为0的宏。
函数malloc()的原型为： void *malloc(unsigned int size)

其中，参数size为无符号整型数，表示向系统申请的空间的大小，函数调用成功将返回一个指向void类型的指针。

ANSI C标准要求，动态分配系统返回void*指针(Pointer to void),void*指针是ANSI C 新标准中增加的一种指针类型，它是一个可以表示任何指针类型的通用指针，常用来说明其基类型未知的指针，即定义一个指针变量，但不指定它指向哪一种基类型的数据。由第7章可知，仅在类型相同时，一个指针才能赋值给另一个指针。因此，如果要将malloc(0函数调用的返回值赋值给某个指针，则应先根据该指针的基类型，用强制类型转换将malloc()函数返回的指针值强制转换为所需的类型，然后再进行赋值操作。例如： int *pi NULL; pi (int *)malloc(2);

其中，malloc(2)表示申请一个长度为2字节的存储空间，malloc(2)的返回值经强制类型转换后再赋值给指针变量pi,即执行语句pi=(int*)malloc(2)后，表示用一个指向int数据的指针变量pi指向这段存储空间的首地址。
如果不知道所用机器上某种类型数据所占内存空间的字节数，可先用sizeof(0计算出本系统中该类型需占内存空间的字节数，然后再用函数malloc(0向系统申请具体的存储空间。

使用sizeof(0确定所需申请的内存空间字节数能提高程序的可移植性，例如： pi=(int *)malloc(sizeof(int));

2.函数calloc()

函数calloc()用于给若干同一类型的数据项分配连续的存储空间，其中每个数据项的长度单位为字节。与malloc()不同的是：通过调用函数calloc(0所分配的存储单元，系统将其自动置初值0。因此，从安全的角度而言，使用calloc0动态分配内存更明智。

其中，第一个参数num表示向系统申请的内存空间的数量，第二个参数size表示申请的每个空间的字节数。若函数调用不成功，函数将返回空指针(NULL):若函数调用成功，将返回一个Void类型的连续存储空间的首地址。如果要将该地址赋给某个指针，则应先根据该指针的基类型，将返回值进行相应的类型转换，然后再进行赋值操作。例如：



  

![CleanShot 2023-03-19 at 19.38.16@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-19%20at%2019.38.16@2x.png)

表示系统申请10个连续的float类型的存储单元，并用指针pf指向该连续存储单元的首地址， 系统申请的总的存储单元字节数为10*sizeof((float)。

显然，用函数calloc()申请的存储单元相当于一个一维数组。函数calloc(O的第一个参数决定一维数组的长度，第二个参数决定数组元素的类型，函数的返回值就是数组的首地址。

3.函数free()

函数free()的原型为： void free(void *p)

该函数的功能是释放动态申请的由指针p指向的存储空间，该函数无返回值。函数free()中参数给出的地址只能是由函数malloc()和calloc()申请空间时返回的地址。该函数执行后， 将以前分配的由指针p指向的存储单元交还给系统，由系统重新支配。

4.函数realloc()

函数realloc()用于改变原来分配的存储空间的大小，其原型为： void *realloc(void *p, unsigned int size);

该函数的功能是将指针p所指向的存储空间的大小改为siz字节，函数返回值是新分配的存储空间的首地址，与原来分配的首地址不一定相同。

【编程提示】因为由动态内存分配得到的存储单元没有名字，只能通过指针来引用它， 所以一旦改变了指针的指向，原来分配的存储单元及存放于其中的数据也就随之丢失了，从而造成内存泄漏。因此，虽然这个指针是一个变量，但也不要轻易地改变它的值。

【编程提示】因为堆空间是有限的，所以动态分配内存后，必须检查函数alloc0的返回值，确保在指针使用前不是NULL,即非空指针，任何空指针均意味着它不指向任何对象， 不应该使用它。如果使用空指针，则可能导致程序崩溃。





### 6.7 使用const修饰指针变量

①const放在类型关键字的前面。假设有如下变量定义语句：

int a,b；

那么，语句： const int *p=&a;

说明*p是一个常量，即只读的，而p不是。只要我们按照从右到左的顺序来读这条语句，就可以看到这一点，即“p是一个指针变量，可以指向一个整型常量(Integer Constant)”。这时， 不可以在程序中修改*p,也就是说，执行“*p=10”这样的赋值操作，将被视为非法。在Visual C+下编译会显示如下错误信息提示： error C2166:1-value specifies const object 注意，虽然*p是不可修改的，但是p指向的变量a的值仍然是可修改的，即执行a=10 这样的赋值操作是合法的。由于指针变量p的值是可以修改的，因此，如果执行p=&b这样的赋值操作，也是合法的。经过这个赋值语句之后，指针变量p就不再指向变量a,而是指向变量b。

2. const放在类型关键字的后面和*变量名的前面。

​	int const *p=&a

说明*p是一个常量，即只读的，而p不是。按照从右到左的顺序，这个定义可以读作“p是一个指针变量，可以指向一个常量整数(Constant Integer)”。它说明不能使用指针变量p修改这个“为常数的整型数”，它和第一种情况是等价的。

3. const放在类型关键字*的后面和变量名的前面

   int*const p= &a;

   说明p是一个常量，即只读的，而*p不是。按照从右到左的顺序，这个定义可以读作“p 是一个常量指针，可以指向一个整数(Integer)”。这时，指针p是一个常量，其值是不可以修改的，即不能在程序中修改指针p让它指向其他变量，但是它所指向的变量的值是可以修改的。

4. ④一个const放在类型关键字的前面，另一个const放在类型关键字*的后面和变量名的前面。例如，语句：

   1. const int*const p =&a;

      说明p和*p都是一个常量，即只读的。按照从右到左的顺序，这个定义可以读作“p是一个常量指针，可以指向一个整型常量(Integer Constant)”。这时，无论执行*p=20还是执行p= &b,这样的赋值操作都是非法的。

   【编程提示】C语言的许多标准库函数都将某些指针参数的类型前加上了cost修饰（上面第一种用法)，目的是只允许函数访问该指针参数指定地址中的内容，不允许修玫其内容， 从而对参数起到一定的保护作用。

## 7、结构体与共用体

### 7.2 结构体类型与结构体变量

结构体(Structure)是一个或多个相同数据类型或不同数据类型的变量集合在一个名字下的用户自定义数据类型。

结构体的声明指定了结构体数据类型的构成。其声明以关键字struct开始，标准形式如下： 

![CleanShot 2023-03-18 at 20.54.22@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-18%20at%2020.54.22@2x.png)

#### 7.2.2 用typedef定义结构体类型

struct STUDENT建立了一个别名Student:: typedef struct STUDENT Student; 

注意，这里只是为已有的类型struct STUDENT定义了一个新的名字，并未定义一种新类型。这样以后就可以用Student来直接定义结构体变量、结构体数组、结构体指针等，

![CleanShot 2023-03-18 at 21.15.46@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-18%20at%2021.15.46@2x.png)

#### 7.2.3 结构体变量的定义

C语言规定了如下三种定义结构体变量的方法。

(1)先声明结构体类型，再定义结构体变量

(2)在声明结构体类型的同时定义结构体变量

​	![CleanShot 2023-03-18 at 21.24.46@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-18%20at%2021.24.46@2x.png)

(3)直接定义结构体变量

不出现结构体名，声明结构体类型的同时定义结构体变量，

![ss](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-18%20at%2021.25.15@2x.png)

#### 7.2.4 指向结构体变量的指针

一个结构体变量的指针是该结构体变量所占的内存空间的首地址。

![CleanShot 2023-03-18 at 21.26.04@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-18%20at%2021.26.04@2x.png)

#### 7.2.5 结构体变量的引用和初始化

C语言规定了两种运算符可用于访问结构体成员：一种是成员运算符，也称圆点运算符(.):另一种是指向运算符，也称箭头运算符(->)。
访问结构体变量的成员用成员运算符，标准访问方式如下： 结构体变量名.成员名

对定义为指向结构体的指针变量，用指向运算符访问其指向的结构体成员，访问形式

如下： 指向结构体的指针变量名->成员名

![sss](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-18%20at%2021.27.57@2x.png)

对于定义为指向结构体的指针变量，也可以用成员运算符访问，但这种方式不常用。

字符数组，赋值时必须用strcpy进行赋值。所以，在对结构体变量的成员进行操作时，必须注意成员数据类型。



### 7.3.结构体数组

#### 7.3.1 结构体数组的定义

①声明结构体类型

2. 定义结构体数组。与基本数据类型的数组定义方法相同
3. struct s STUDENT stu[30];
   1. 它定义了一个数组，最多可包含30个元素，每个元素的数据类型为struct STUDENT。该数组所占的内存空间大小为30*sizeof(struct STUDENT)字节。

#### 7.3.3 指向结构体数组的指针

结构体数组一旦定义，系统将为其申请一段连续的存储空间，指向该结构体数组的指针可用来对该结构体数组元素进行操作。

### 7.4向函数传递结构体

把结构体传递给函数的方式有三种：传递单个成员、传递整个结构、传递指向结构的指针。

(1)用结构体变量的单个成员作为函数参数

	1. 用单个结构体成员作为实参，与普通的函数参数的值传递没有区别，都是单向值传递， 在函数内部对参数进行操作，不会引起结构体成员值的改变。

(2)用结构体变量或结构体数组作为函数参数

​	因为这种传递方式将结构体变量或结构体数组的所有成员都传递给被调函数，所以效率较低，不常用，并且在函数内部对结构体成员值的改变，不会引起主调函数的结构体成员值的改变。

(3)用指向结构体的指针作为函数参数

​	因为这种方式的实质是传递结构体变量或结构体数组的首地址，并非将全部结构体成员的内容复制给被调函数，所以比前一种方式效率高。同时，因为是地址传递，所以在函数内部对结构体成员值的改变将影响主调函数的结构体变量的成员值。



### 7.5动态数据结构

略

### 7.6共用体

略

## 8、文件操作

### 8.3基本文件操作

基本文件操作需要了解5个库函数：

1. open()
2. read()
3. write()
4. close()
5. seek()。

大多数编译器都将它们定义在fcnt.h中。

#### 8.3.1 基本文件操作函数

1.打开文件open()

int open(const char *pathname,int access,unsigned mode);

![CleanShot 2023-03-19 at 10.46.16@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-19%20at%2010.46.16@2x.png)

返回值一如果成功打开，则返回一个文件句柄，否则返回-1，并用外部全局变量ermo 说明错误类型。

有一个专门的函数用来建立并打开新文件： int creat(const char *pathname,unsigned mode);

它相当于access为O_CREATJO_WRONLYJO_TRUNC的open0,参数和返回值的含义与open( 完全相同。

2.读文件read()

文件内的数据读入内存后才能被使用。它的原型和说明如下： int read(int handle,void *buf,unsigned len);

handle一文件的句柄。
buf一内存缓冲区指针。数据将读入该指针指向的内存。
len一试图读入的字节数。其值不能超过buf所指向的可用内存大小，否则很可能产生越界。

返回值一实际读入的字节数。0表示读到文件末尾；-1表示出错，用emo说明错误类型

在文件操作中，有一个隐含的文件位置指针，简称位置指针，它是一个整数，记录着当前读到的是文件的第几个字节。无论read()函数还是马上要介绍的writeO函数，都在位置指针指向的位置开始读/写操作。用O APPEND模式打开的文件，位置指针直接指向文件末尾， 否则指向文件首字节。每次读/写若干字节后，位置指针都向后移动同样数量的字节。整个文件就像水流一样从位置指针面前流过，形成了文件流。

read()的返回值说明了实际读入的字节数，位置指针立刻按此数值向后移动，下一次read() 就会接着这次结束的位置继续。

返回值永远不会大于len。在一般情况下，如果数据内容的长度多于len,则只读入len 字节；如果少于len,就有多少读多少。

3.写文件write()

write()和read()在形式和使用上都很像：

int write(int handle,void *buf,unsigned len);

handle-一文件的句柄。
buf,len一把从buf开始的len字节写入文件。

返回值一实际写入的字节数。-1表示出错，用emo说明错误类型。

write()和read()共用同一个位置指针。在以O RDWR方式打开文件时要特别注意此问题。



4.关闭文件close()

close()的语法非常简单： int close(int handle);

如果关闭失败，则返回-1，用ermo说明错误类型；否则返回0。

如同malloc()和free()一样，open()和close().总是成对出现。建议不要把配套的open(O和close0分开，尽量放在同一个函数内。在编写代码时，写下open()的同时，马上也写下close(), 然后在它们之间插入代码。

5.文件定位Iseek()

对文件流的流控体现在此函数上。它可以随时让位置指针指向文件的任意位置。

其语法形式如下： long lseek(int handle,long offset,int fromwhere);

handle-一文件的句柄。
offset-一从fromwhere开始，移动位置指针offset字节。offset为正，表示向文件末尾移动；为负表示向文件头部移动。移动的字节数是offset的绝对值。

fromwhere一fromwhere的取值是下面三个宏中的任意一个： ·SEEK SET从文件头移动。
SEEK CUR从当前位置指针位置移动。
SEEK END从文件尾移动。
返回值一移动后的指针位置。-lL表示出错，用emo说明错误类型。

返回值一移动后的指针位置。-lL表示出错，用ermo说明错误类型。
例如，从当前位置向后跳过4字节： lseek(fh,4L,SEEK CUR); 跳到文件倒数第10字节： lseek (fh,-10L,SEEK END); 下面的代码巧妙地利用了lseek0得到一些有用信息： int curPos lseek(fh,OL,SEEK CUR); //得到当前位置指针的位置int fi1 eLength=1seek(Eh,0L,SEEK END);/得到文件长度

#### 8.3.2错误处理

void perror(const char *s);

![CleanShot 2023-03-19 at 10.55.34@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-19%20at%2010.55.34@2x.png)

### 8.4高级文件操作

#### 8.4.1.文件的打开与关闭

fopen()和fclose()分别用来打开和关闭文件，原型如下： FILE *fopen(const char *filename,const char *mode)i int fclose(FILE *fp);

从fclose()的参数可以看出来，fopen()的返回值是一个类似文件句柄的东西。这里它被称为文件指针(File Pointer)。FILE是在stdio.h中定义的结构体类型，封装了与文件有关的一系列变量，包括文件句柄、位置指针及缓冲区等。如果文件打开失败，则返回值为NULL, 错误代码存放在errno中。

fopen()的参数mode是文件打开方式.

![CleanShot 2023-03-19 at 10.57.53@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-19%20at%2010.57.53@2x.png)



#### 8.4.2 文件的读/写

1.读/写字符int fgetc(FILE *fp); 从p读出一个字符并返回。

若读到文件末尾，则返回EOF。int fputc(int c,FILE *fp); 

向fp输出字符c。如果写入错误，则返回EOF,否则返回c。

2.读/写字符串

char *fgets(char *s,int n,FILE *fp);

从fp读入字符串，存入s,最多读n-1个字符。当读到换行回车符、文件末尾或读满n-1个字符时，函数返回，且在字符串末尾添加'\0'结束符。

int fputs(const char *s,FILE *fp);

将字符串s输出到p。错误时返回EOF,否则返回一个非负数。

3.格式化读/写

int fscanf(FILE*fp,const char*format,…）;

从fp读入数据。其余参数和返回值与scanf()相同。

int fprintf(FILE *fp,const char *format,);

向fp写数据。其余参数和返回值与printf()相同。

4.按数据块读/写

unsigned fread(void *ptr,unsigned size,unsigned nmemb,FILE *fp);

从fp读数据块到ptr。size是每个数据块的大小，nmemb是最多允许读的数据块个数。返回值是实际读到的数据块个数。

unsigned fwrite(const void *ptr,unsigned size,unsigned nmemb,FILE *fp);

把ptr指向的数据块写入fp。size是每个数据块的大小，nmemb是最多允许写的数据块个数。
返回值是实际写入的数据块个数。

5.文件定位

int fseek(FILE *fp,long offset,int fromwhere);

把fp的文件位置指针从fromwhere开始移动offset字节。如果成功，则返回0值，否则返回非O值。fromwhere的值也是SEEK CUR、SEEK END和SEEK SET。

void rewind(FILE *fp);

让p的文件位置指针指向文件首字节。
long  ftell(FILE*fp);

返回p的当前文件位置指针。出错时返回-1L

6.判断文件是否结束

int feof(FILE *fp); 

当文件位置指针指向p末尾时，返回非0值，否则返回0值。

7.判断前一次文件操作是否有错误发生

int ferror(FILE *fp);

int fflush(FILE *fp);



#### 8.4.4 标准输入与标准输出

printf()和fprintf()很像，差别仅在于一个FILE*fp。它们之间有什么血缘关系吗？ C语言定义了三个特别的文件指针常数：stdin、stdout和stderr,分别称为标准输入、标准输出和标准错误输出。如果提供给fprintfo的第一个参数是stdout,它和printf()就完全一样了。这个道理对fputc()与putchar(),fgetc()与getchar(),fputs()与puts,fgets()与gets()等也适用。具体来说，函数putchar()的实现只有一行语句





## 9、一些使用中的QA

Q1:C语言结构体中的数组为什么可以通过 struct A a ={1,2,3}这种形式来赋值

```
C语言中的结构体可以包含数组类型的成员变量，数组类型的成员变量本质上是一段连续的内存空间，可以存储多个元素。可以通过结构体变量名加成员名的方式来访问结构体中的数组元素。

在C语言中，结构体变量的初始化可以通过在定义时使用大括号来实现，其中大括号中包含的是按顺序排列的成员变量的初始值。对于数组类型的成员变量，可以在大括号中使用逗号分隔的方式，一一列出数组中的各个元素的初始值。例如，使用如下的方式初始化一个包含三个int类型的数组的结构体变量A：


```

```c
struct A {
    int arr[3];
};

struct A a = {1, 2, 3};
```

在这个例子中，结构体类型A包含一个名为arr的int类型数组成员变量，数组中有3个元素。变量a是A类型的一个结构体变量，用大括号中的值初始化了a中的数组元素。这样做的效果就是a.arr[0]被初始化为1，a.arr[1]被初始化为2，a.arr[2]被初始化为3。

需要注意的是，结构体变量的初始化时必须按照成员变量的声明顺序依次进行初始化。如果想要初始化结构体中的某个特定成员变量，可以在大括号中使用成员名来指定初始化的值。例如：

```c
struct A {
    int x;
    int arr[3];
    int y;
};

struct A a = {.x = 1, .arr = {2, 3, 4}, .y = 5};

```

在这个例子中，结构体类型A包含三个int类型成员变量，依次为x、arr和y。变量a用大括号中的初始化值初始化了结构体变量，其中使用了成员名来指定arr成员变量的初始化值。这样做的效果是a.x被初始化为1，a.arr[0]被初始化为2，a.arr[1]被初始化为3，a.arr[2]被初始化为4，a.y被初始化为5。
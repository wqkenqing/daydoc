title:  c learn
date:  2023年 3月 7日
tags: [c、考研、复试]
password: 7FKBKZrTTTPG2LnC

---

考研复试、程序设计

 <!--more-->

# 程序设计 （C）

## 1、数据类型&运算符&表达式



C程序常见符号分类

1. 关键字(keyword)
2. 标识符(identifier)
   1. 标识符分为系统预定义标识符和用户自定义标识符两类。
3. 运算符(Operator)
   1. ![CleanShot 2023-03-16 at 14.37.09@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2014.37.09@2x.png)

![CleanShot 2023-03-16 at 15.49.57@2x](/Users/kuiqwang/Library/Application%20Support/CleanShot/media/media_9OqdQ0K5yL/CleanShot%202023-03-16%20at%2015.49.57@2x.png)

 	4. 分隔符 (Separator )
     	1. 就像写文章要有标点符号 一样，写程序也要有 一些分隔符。在 C 程序中，空格、回车/ 换行、逗号等，在各自不同的应用场合起着分隔符的作用。

**C 语 言 提 供 的 数 据 类 型 (D a t a T y p e ) 分 类 如 下**

​	![CleanShot 2023-03-16 at 15.52.07@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2015.52.07@2x.png)

基本数据类型有三种:

1. 字符(char)
2.  整数(int)
3. 和浮点数(float)。

复杂的类型都是基于它们构建的。

**字符类型**

```
上面示例中，变量 t 为单引号字符，由于字符常量必须放在单引号里面，所以内部的单引号要使用反斜杠转 义。
这种转义的写法，主要用来表示 ASCII 码定义的一些无法打印的控制字符，它们也属于字符类型的值。
\a :警报，这会使得终端发出警报声或出现闪烁，或者两者同时发生。
\b :退格键，光标回退一个字符，但不删除字符。
\f :换⻚符，光标移到下一⻚。在现代系统上，这已经反映不出来了，行为改成类似于 \v 。 \n :换行符。
\r :回⻋符，光标移到同一行的开头。
\t :制表符，光标移到下一个水平制表位，通常是下一个8的倍数。
\v :垂直分隔符，光标移到下一个垂直制表位，通常是下一行的同一列。
\0 :null 字符，代表没有内容。注意，这个值不等于数字0。
转义写法还能使用八进制和十六进制表示一个字符。 \nn :字符的八进制写法， nn 为八进制值。
\xnn :字符的十六进制写法， nn 为十六进制值。
```



```
char x = 'B';
char x = 66;
char x = '\102'; // 八进制 char x = '\x42'; // 十六进制
```



**整数类型**

整数类型用来表示较大的整数，类型声明使用 int 关键字。

```
int a;
```

```
不同计算机的 int 类型的大小是不一样的。比较常⻅的是使用4个字节(32位)存储一个 int 类型的值，但
是2个字节(16位)或8个字节(64位)也有可能使用。它们可以表示的整数范围如下。
16位:-32,768 到 32,767。
32位:-2,147,483,648 到 2,147,483,647。 64位:-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。

```

**signed，unsigned**

C 语言使用 signed 关键字，表示一个类型带有正负号，包含负值;使用 unsigned 关键字，表示该类型不 带有正负号，只能表示零和正整数。

对于 int 类型，默认是带有正负号的，也就是说 int 等同于 signed int 。由于这是默认情况，关键 字 signed 一般都省略不写，但是写了也不算错。

```
signed int a;
// 等同于
int a;
```

int 类型也可以不带正负号，只表示非负整数。这时就必须使用关键字 unsigned 声明变量。

```
unsigned int a;
```

整数变量声明为 unsigned 的好处是，同样⻓度的内存能够表示的最大整数值，增大了一倍。比如，16位 的 signed int 最大值为32,767，而 unsigned int 的最大值增大到了65,535。

unsigned int 里面的 int 可以省略，所以上面的变量声明也可以写成下面这样。

```
unsigned a;
```

字符类型 char 也可以设置 signed 和 unsigned 。

```
signed char c; // 范围为 -128 到 127 
unsigned char c; // 范围为 0 到 255
```

注意，C 语言规定 char 类型默认是否带有正负号，由当前系统决定。这就是说， char 不等同于 signed char ，它有可能是 signed char ，也有可能是 unsigned char 。这一点与 int 不同， int 就是等同于signed int 。

**整数的子类型**

如果 int 类型使用4个或8个字节表示一个整数，对于小整数，这样做很浪费空间。另一方面，某些场合需 要更大的整数，8个字节还不够。为了解决这些问题，C 语言在 int 类型之外，又提供了三个整数的子类 型。这样有利于更精细地限定整数变量的范围，也有利于更好地表达代码的意图。

```
short int (简写为 short ):占用空间不多于 int ，一般占用2个字节(整数范围为-32768~ 32767)。
long int (简写为 long ):占用空间不少于 int ，至少为4个字节。
long long int (简写为 long long ):占用空间多于 long ，至少为8个字节。
```

```
short int a;
long int b;
long long int c;
```

默认情况下， short 、 long 、 long long 都是带符号的(signed)，即 signed 关键字省略了。它们也

可以声明为不带符号(unsigned)，使得能够表示的最大值扩大一倍。

```
unsigned short int a;
unsigned long int b;
unsigned long long int c;
```

C 语言允许省略 int ，所以变量声明语句也可以写成下面这样

```
short a;
unsigned short a;
long b;
unsigned long b;
long long c;
unsigned long long c;
```

不同的计算机，数据类型的字节⻓度是不一样的。确实需要32位整数时，应使用 long 类型而不是 int 类 型，可以确保不少于4个字节;

确实需要64位的整数时，应该使用 long long 类型，可以确保不少于8个字 节。另一方面，为了节省空间，只需要16位整数时，应使用 short 类型;需要8位整数时，应该使用 char 类型。

**标识符命名**

标识符的命名必须遵循一定的规则。这里只介绍被大多数程序员所采纳的共性规则。一 般 的 标 识 符 命 名 规 则 (N a m i n g R u l e s ）

1. 由英文字母、数字和下画线组成，且必须以英文字母或下画线开头。
2.  不 允 许 使 用 关 键 字 作 为 标 识 符 的 名 字， 同 时 标 识 符 名 也 不 应 该 与 库 函 数 名 重 名 。
3. 在C 语言中，标识符可以是任意长度的。
4. 标识符命名应以直观且易于拼读为宜。
5. 命名规则应尽量与所采用的操作系统或开发工具的风格保持 一致。

6. 标识符区分大小写

**常量**

常量(Constant)是一种在程序中保持类型和值都不变的数据。按照类型划分有以下几种常量：整型常量、实型常量、字符常量、字符串常量、枚举常量。除枚举类型外，编译系统从它们的数据表示形式上就能区分它们的类型。

计算机中的数据都以二进制形式存储。在C程序中，为便于表示和使用，整型常量可用

1. 十进制(Decimal)
2. 八进制(Octal)
3. 十六进制(Hexadecimal)

三种形式来表示，编译系统会自动将其转换为二进制形式存储。整型常量的表示形式如表2-1所示。

![CleanShot 2023-03-16 at 16.10.53@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.10.53@2x.png)

2.整型常量的类型确定

长整型常量由常量值后跟L或1来表示，如-2561、1024L等。
无符号整型常量由常量值后跟U或u来表示，如30u、256U等，但不能表示成小于0 的数（如-30u)。无符号长整型常量由常量值后跟LU、Lu、IU或lu来表示，如30lu等。

**实型常量**

1.实型(Float)常量的表示形式

(1)十进制小数形式

```
十进制小数形式与人们表示实数的惯用形式相同，是由数字和小数点组成的。注意，必须有小数点，如0.123、-12.35、.98、18.等都是合法的表示形式，其中，98等价于0.98,18.
等价于18.0。如果没有小数点，则不能作为小数形式的实型数。
```

(2)指数形式

```
在实际应用中，有时会遇到绝对值很大或很小的数。这时，我们将其写成指数形式，更直观、方便，如0.00000345写成3.45×106，或者0.345×10~7。程序编辑时不能输入角标，因此在C语言中，以字母e或E来代表以10为底的指数。如0.00000345写成3.45e-6,或者0.345e-5。其中，e的左边是数值部分（有效数字），可以表示成整数或者小数形式，它不能省略：e的右边是指数部分，必须是整数形式。例如，3e-2、3.0e-2、3.e-2、.6e-2等都是合法的表示形式，而e3、2e3.0、.e3等都是不合法的表示形式。
```

2.实型常量的类型确定

```
实型常量隐含按双精度型（double)处理。
单精度实型常量由常量值后跟F或f来表示，如1.25F、1.25e-2f等。
长双精度(long double)实型常量由常量值后跟L或1来表示，如l.25L等。
```

**字符常量**

```
C语言中的字符常量是由单引号括起来的一个字符，如'a'、2'、#等。字符常量两侧的一对单引号是必不可少的，如B是字符常量，而B则是一个标识符；再如，3表示一个字符， 而3则表示一个整数。为了表示某些控制字符（如回车符、换行符等），C语言中还引入了另一种特殊形式的字符常量一转义序列(Escape Sequence),它是以反斜线“”开头的字符序列，使用时同样要括在一对单引号内。这里的反斜线“1”有着特殊的含义，编译器会将其视为转义字符(Escape Character)。当编译器遇到字符串中的转义字符时，它会将转义字符及其下一个字符组成一个转义序列。常用的转义序列及其含义见表2-2。
```

![CleanShot 2023-03-16 at 16.34.49@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.34.49@2x.png)

**字符串常量**

字符串常量是由一对双引号括起来的一个字符序列，如"qwe"、"123"、"w"等都是字符串。注意，"a"是字符串常量，不是字符常量，'a'才是字符常量。
为便于C程序判断字符串是否结束，系统对每个用双引号括起来的字符串常量都添加一个字符串结束标志一A$CⅡ码值为0的空操作符"\0"。它不引起任何控制动作，也不显示。

**宏常量**

宏常量，也称符号常量(Symbolic Names or Constants),是指用一个标识符号代表的个常量，这时该标识符号与此常量是等价的。宏常量是由C语言中的宏定义编译处理命令来定义的。宏定义的一般形式为：

#define 标识符字符串

其作用是用#define编译预处理指令定义一个标识符和一个字符串，凡在源程序中发现该标识符时，都用其后指定的字符串来替换。宏定义中的标识符被称为宏名(Macro Name),将程序中出现的宏名替换成字符串的过程称为宏替换(Macro Substitution)。宏名与字符串之间可以有多个空白符，但字符串后只能以换行符终止，且除非特殊需要一般不出现分号。

例如： #define PI 3.14159 

它的作用是在编译预处理时，把程序中在该命令之后出现的所有标识符PI均用3.14159代替。

其优点在于，能使用户以一个简单的名字代替一个长的字符串，提高程序的可读性。

![CleanShot 2023-03-16 at 16.39.31@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.39.31@2x.png)

**枚举常量**

```
所谓“枚举(Enumeration)”就是一一列举之意，当某些量仅由有限个数据值组成时， 通常用枚举类型来表示。枚举数据类型(Enumerated Data Type)描述的是一组整型值的集合， 可用关键字enum来定义这种类型。
例如： enum response(no,yes,none); enum response answer; 
这两条语句首先声明了名为response的枚举数据类型，
它有三种可能的取值：no、yes、none,然后用该枚举类型定义了一个名为answer的变量。
在枚举类型声明语句中，包含在花括号内的标识符均为整型常量，称为枚举常量。
除非特别指定，否则这组常量中的第1个常量的值为0，第2个常量的值为1，第3个常量的值为2,以后依次递增1。
在上例中，变量answer可被赋予no、yes、none这三种值中的任何一种。
例如： answer no 相当于： answer =0; 变量answer还可以用在条件语句中，例如： 
if (answer ==yes) 
相当于： if (answer ==1) 使用枚举类型的目的是提高程序的可读性。
例如，在上例中，使用no、yes、none比使用0、1、2的程序可读性更好。
在上例中，response被称为枚举标记(Enumeration Tag),枚举标记是可选的(Optional), 也可以省略不写。
例如： enum(no,yes,nonelanswer; C语言还允许在枚举类型定义时，明确地设置每一个枚举常量的值，
例如： enum response(no =-1,yes =1,none =0}; 若要在枚举类型定义中增加一种可能的取值，那么在“{”和“}”之间直接添加即可。
例如： enum response(no =-1, yes =1,none =0,unsure 2); 
其他类似的例子还有： enum month{JAN=1,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC}; 
这里，第一个枚举常量值被明确地设置为1，以下的常量值依次递增1。再如：
```

```
理解枚举类型的要点是：枚举标记后面变量表中的每个标识符都代表一个整型常数
这些标识符只是一个整型常数的名字，不是字符串，因此它们可以用于使用整型常数值的任何场合，但不能将其作为字符串直接输入和输出。
例如下面的语句并不能达到输出字符串"yes" 的目的。
answer 1; 
printf("%s",answer);/错误
```

**变量**

**变量的定义与初始化**

```
整型的类型关键字为int,单精度实型的类型关键字为float,双精度实型的类型关键字为double,字符型的类型关键字为char。
变量类型决定了编译器为其分配的内存单元的字节数、内存单元中能存放哪种类型的数据、数据在内存中的存储形式、该类型变量合法的取值范围及可参与的运算种类。
例如： short max; //等价于语句short 
int max; long sum; //等价于1ong int sum; 
unsigned int area;/定义area为无符号整型变量
float score; //定义score为单精度实型变量
double total; //定义tota1为双精度实型变量
char sex; //定义sex为字符型变量
```

**const类型修饰符**

const类型修饰符必须放在它所修饰的类型名之前，用const修饰的标识符为常量，编译器将其放在**只读存储区**。因此，const常量只能在定义时赋初值，不能在程序中改变其值。
例如： const float pi 3.1415926;

与用#define足义的宏常量相比，const常量的优点如下：

 ①const常量有数据类型，而宏常量没有数据类型。编译器对const常量进行类型检查， 但对宏常量只进行字符串替换，不进行类型检查，字符串替换时极易产生意想不到的错误。
②有些集成化的调试工具可对cost常量进行调试，而不能对宏常量进行调试。



**使用变量时的注意事项**

1.使用变量的基本原则使用变量必须遵循“先定义，后使用”的原则，一条定义语句可以定义若干同类型的变量，其中变量定义的先后顺序无关紧要。C语言要求所有变量必须在第一条可执行语句前定义。
2.注意区分变量名和变量值的概念 变量名标识内存中一个具体的存储单元，变量值则是存储单元中存放的数据。
3.int型变量隐含的修饰类型定义整型变量时，只要不指定为无符号型(unsigned),其隐含的类型就是有符号型(signed)。在实际使用时，signed通常都是省略不写的。
4.用sizeof获得类型或变量的字长（所占存储空间的大小）

注意，sizeof（）是C语言提供的专门用于计算类型字节数的运算符，不是函数。例如，计算int型数据所占内存的字节数用sizeof(int)计算即可。
![CleanShot 2023-03-16 at 16.57.28@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2016.57.28@2x.png)

**注意实型数据内存存储格式的特殊性**

与整型数据在内存中的存储方式不同，对于实型数据，无论是小数表示形式还是指数表示形式，在内存中都是用浮点方式来实现存储的。

所谓浮点数，是指小数点的位置是可以浮动的数。例如，十进制数1234.56可以写成： 1234.56=0.123456×104=1.23456×103=12345.6×10-1 这里，随着10的指数的变化，小数点的位置也会发生相应的变化。

浮点数与整数在内存中的存储方式是截然不同的，浮点数永远是以如下顺序的位序列存储在内存中的：符号(+或-)，阶码(Exponent),尾数(Significand)。例如，实数N可表示为：

![CleanShot 2023-03-16 at 17.00.01@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.00.01@2x.png)

![CleanShot 2023-03-16 at 17.01.03@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.01.03@2x.png)

![CleanShot 2023-03-16 at 17.01.19@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.01.19@2x.png)

阶码所占的位数决定实数的取值范围；'尾数所占的位数决定实数的精度，尾数的符号决定实数的正负。对于阶码和尾数各自占多少存储空间，标准C并没有明确规定，不同的C编译系统分配给阶码和尾数的存储空间是不同的。显然，这种浮点表示法所能表示实数的取值范围可以远远大于定点表示法，而且也更灵活。

**注意char型数据与int型数据之间的关系**

一个字符型变量中只能存放一个字符。字符串的存储需要用到字符数组，将在第6章中介绍它。字符变量的取值范围取决于计算机系统所使用的字符集。目前，计算机上广泛使用的字符集是ASCII码（美国标准信息交换码）字符集。该字符集规定了每个字符所对应的编码，即在字符序列中的“序号”。也就是说，每个字符都有一个等价的整型值与其相对应。
从这个意义上说，char型可看成一种特殊的整型数。附录D给出了常用字符的ASCII对照表。
一个int型数据在内存中是以二进制形式存储的，而一个字符在内存中也是以其对应的ASCII码的二进制形式存储的。例如，对于字符A',内存中存储的是其ASCII码65的二进制值，存储形式与int型数65类似，只是在内存中所占字节数不同而已。char型数据占1字节，而it型数据在16位编译系统中占2字节，在32位编译系统中占4字节。
因此，在C语言中，只要不超出ASCIⅡ码的取值范围，char型数据和int型数据之间的相互转换就不会丢失信息，这也说明，char型常量可参与任何int型数据的运算。

**注意实型变量数据的舍入误差**
![CleanShot 2023-03-16 at 17.05.22@2x](http://img.wqkenqing.ren/typora_img/CleanShot%202023-03-16%20at%2017.05.22@2x.png)

这是因为浮点数并不是真正意义上的实数，它只是实数在某种范围内的一种近似。事实上，在CPU的内部，所有的浮点数在被浮点指令装入浮点寄存器时都会发生转换，从单精度、双精度、整数转换为扩展精度，当从浮点寄存器存入内存时又会发生转换，从扩展精度转换为相应的精度格式，这种转换是由CPU硬件自动完成的。正是由于从扩展精度转换为低精度格式这一行为的存在，会让程序在进行浮点数赋值或浮点数相等比较时出现奇怪的结果。
当数据从低精度格式转换到高精度格式时，一般而言不会引起精度的丢失，因此，这样的转换相对是安全的，随着表示数据的位数的增加，高精度格式可以把低精度格式的相应数据位复制过来，通常不会丢失任何信息，但long型转换为float型是一个例外，因为当long 型整数的位数超过7位时，转换为float型后，会因f1oat型的有效位数不高于7位而发生数据信息丢失。从高精度向低精度进行转换时，当数值超出低精度数据类型的表数范围时，有可能发生数值溢出，即使数值没有超出低精度数据类型的表数范围，也有可能发生数据信息丢失，因为低精度格式的数据位数比高精度的少，容纳不下高精度的所有信息，这样就会出现舍入(Round),也称截断。
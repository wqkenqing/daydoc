title:  线性表、栈、队列
date:  2023年 5月19日
tags: []
password: 7FKBKZrTTTPG2LnC

---

 线性表、栈、队列

 <!--more-->

 ## 线性表

 ### 定义

 具有相同数据类型的n(n>=0)个元素的有限序列，其中n为表长。

线性表是一种逻辑结构，表示元素之间一对一的相邻关系，顺序表和链表是指存储结构。

线性表的ADT

```
typedef struct {
    // 线性表的数据存储区
    ElementType *data;

    // 线性表的当前长度
    int length;

    // 线性表的最大容量
    int capacity;
} LinearList;

// 初始化一个空的线性表
void Init(LinearList *list);

// 销毁线性表
void Destroy(LinearList *list);

// 将线性表清空
void Clear(LinearList *list);

// 判断线性表是否为空
bool IsEmpty(LinearList *list);

// 获取线性表的长度
int Length(LinearList *list);

// 在指定位置插入一个元素
bool Insert(LinearList *list, int position, ElementType element);

// 删除指定位置的元素
bool Delete(LinearList *list, int position);

// 获取指定位置的元素
ElementType Get(LinearList *list, int position);

// 更新指定位置的元素
bool Update(LinearList *list, int position, ElementType element);

// 查找指定元素在线性表中的位置
int Find(LinearList *list, ElementType element);

// 遍历线性表中的所有元素
void Traverse(LinearList *list);

// 其他可能的操作或辅助函数


```


## 栈

### 定义

栈是一种具有特定限制的线性数据结构，它遵循后进先出（LIFO）的原则。栈可以视为一个垂直排列的容器，新元素的插入和删除只能在栈的顶部进行。栈顶是最后一个插入的元素，也是第一个被删除的元素。

栈的主要操作包括入栈（Push）、出栈（Pop）、获取栈顶元素（Top）、判断栈是否为空（IsEmpty）以及判断栈是否已满（IsFull）。入栈操作将一个新元素放置在栈顶，出栈操作将栈顶的元素移除并返回其值，获取栈顶元素操作返回栈顶元素的值，判断栈是否为空操作检查栈中是否有元素，而判断栈是否已满操作则检查栈是否已达到最大容量。

栈常用于需要后进先出顺序的问题，例如函数调用的执行顺序、表达式求值、括号匹配等。栈可以通过数组或链表等数据结构来实现，具体的实现方式可以根据需求和语言特性进行选择。


### 栈的ADT



```

typedef struct {
    // 栈的数据存储区
    ElementType *data;

    // 栈顶指针，指向栈顶元素
    int top;

    // 栈的最大容量
    int capacity;
} Stack;

// 初始化一个空栈
void Init(Stack *stack, int capacity);

// 销毁栈
void Destroy(Stack *stack);

// 将栈清空
void Clear(Stack *stack);

// 判断栈是否为空
int IsEmpty(Stack *stack);

// 判断栈是否已满
int IsFull(Stack *stack);

// 获取栈的大小（元素个数）
int Size(Stack *stack);

// 入栈操作
int Push(Stack *stack, ElementType element);

// 出栈操作
int Pop(Stack *stack);

// 获取栈顶元素
ElementType Top(Stack *stack);

// 其他可能的操作或辅助函数


```


### 队列

定义：
队列是一种按照先进先出（FIFO）原则组织数据的线性结构。
它可以看作是一种特殊的线性表，只能在队尾进行插入操作（入队），在队头进行删除操作（出队）。
元素在队列中的存储是有序的，即先入队的元素先出队，后入队的元素后出队。



```
#define MAX_SIZE 100

typedef struct {
    ElementType data[MAX_SIZE];
    int front;
    int rear;
} Queue;

// 初始化一个空队列
void Init(Queue *queue);

// 销毁队列
void Destroy(Queue *queue);

// 将队列清空
void Clear(Queue *queue);

// 判断队列是否为空
int IsEmpty(Queue *queue);

// 判断队列是否已满
int IsFull(Queue *queue);

// 获取队列的大小（元素个数）
int Size(Queue *queue);

// 入队操作
int Enqueue(Queue *queue, ElementType element);

// 出队操作
int Dequeue(Queue *queue);

// 获取队头元素
ElementType Front(Queue *queue);

// 获取队尾元素
ElementType Rear(Queue *queue);

// 其他可能的操作或辅助函数


```



上述是相关结构的顺序存储的实现

---

接下来讲解相关结构的链式存存储的实现



## 链表



```
typedef struct ListNode {
    ElementType data;
    struct ListNode *next;
} ListNode;

typedef struct {
    ListNode *head;
    ListNode *tail;
    int size;
} LinkedList;

// 初始化一个空链表
void Init(LinkedList *list);

// 销毁链表
void Destroy(LinkedList *list);

// 将链表清空
void Clear(LinkedList *list);

// 判断链表是否为空
int IsEmpty(LinkedList *list);

// 获取链表的大小（元素个数）
int Size(LinkedList *list);

// 在链表头部插入一个元素
void InsertFront(LinkedList *list, ElementType element);

// 在链表尾部插入一个元素
void InsertBack(LinkedList *list, ElementType element);

// 在指定位置插入一个元素
void Insert(LinkedList *list, int index, ElementType element);

// 删除链表头部的元素
void RemoveFront(LinkedList *list);

// 删除链表尾部的元素
void RemoveBack(LinkedList *list);

// 删除指定位置的元素
void Remove(LinkedList *list, int index);

// 获取链表指定位置的元素值
ElementType Get(LinkedList *list, int index);

// 修改链表指定位置的元素值
void Set(LinkedList *list, int index, ElementType element);

// 其他可能的操作或辅助函数

```



队列的链表实现

```
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Queue {
    struct Node* front;
    struct Node* rear;
};

struct Queue* createQueue() {
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    queue->front = NULL;
    queue->rear = NULL;
    return queue;
}

int isEmpty(struct Queue* queue) {
    return (queue->front == NULL);
}

void enqueue(struct Queue* queue, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;

    if (isEmpty(queue)) {
        queue->front = newNode;
        queue->rear = newNode;
    } else {
        queue->rear->next = newNode;
        queue->rear = newNode;
    }
}

int dequeue(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty.\n");
        return -1; // 返回一个特殊值作为错误标记
    }

    struct Node* temp = queue->front;
    int data = temp->data;
    queue->front = queue->front->next;

    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);
    return data;
}

int front(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty.\n");
        return -1; // 返回一个特殊值作为错误标记
    }

    return queue->front->data;
}

int rear(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("Queue is empty.\n");
        return -1; // 返回一个特殊值作为错误标记
    }

    return queue->rear->data;
}

int main() {
    struct Queue* queue = createQueue();

    enqueue(queue, 1);
    enqueue(queue, 2);
    enqueue(queue, 3);

    printf("Front element: %d\n", front(queue));
    printf("Rear element: %d\n", rear(queue));

    printf("Dequeued element: %d\n", dequeue(queue));
    printf("Dequeued element: %d\n", dequeue(queue));
    printf("Dequeued element: %d\n", dequeue(queue));

    if (isEmpty(queue)) {
        printf("Queue is empty.\n");
    }

    return 0;
}

```


title:  计算处理
date:  2023-02-20
tags: [java,math,BigDecimal]
password: 7FKBKZrTTTPG2LnC

---

 <!--more-->

> java的计算处理梳理，掌握几个常用的工具类，与处理。

通过调研，常规的java计算方式有

1. 运算符运算
2. Math工具类运算
3. BigDecimal类运用

## 运算符运行

``` 
+ - * / %

```

### 使用案例

略

### 注意事项

优点：

1. 提高代码的执行效率：使用运算符可以提高代码的执行效率，避免使用大量的条件语句和循环语句来实现相同的功能。
2. 简化代码的书写：使用运算符可以简化代码的书写，使代码更加简洁明了。
3. 提高程序的可读性：使用运算符可以使代码更加简单易懂，提高程序的可读性。

#### 缺点

可能会降低代码的可读性：
在使用运算符时，如果没有遵循运算符的优先级规则，容易引起代码的歧义，使代码的可读性降低。例如，以下代码：

```java
int a = 2 + 3 * 4;

```
根据运算符的优先级规则，乘法运算符的优先级高于加法运算符，因此上述代码的运算结果为 14。如果将代码改为以下形式：

```java
int a = 2 + (3 * 4);
```


则可以明确地指定运算的顺序，使代码更加清晰易懂。

可能会引发运算错误：
如果使用运算符时没有注意边界条件或者特殊情况，容易引发运算错误。例如，以下代码：

```java
int a = 10 / 0;
```


在运行时会引发 ArithmeticException 异常，因为除数为 0。因此，在使用运算符时，需要特别注意边界条件和特殊情况，避免引发运算错误。

可能会引起安全问题：
某些运算符，如位运算符，可能会引起安全问题。例如，以下代码：

```java
int a = 1;
a |= 2;
```


在运行时，变量 a 的值会变为 3。如果 a 表示一个权限标志，那么通过位运算修改 a 的值就会造成安全问题。因此，在使用这些运算符时，需要格外小心，避免引起潜在的安全问题。

### Math类的使用

> 发现了取模与取余存在区别。这里要注意，后再继续研究

```
 int a =-5;
        int b = 2;
        System.out.println(Math.abs(a));
        System.out.println(Math.max(a, b));
        System.out.println(Math.min(a, b));
        System.out.println(Math.sqrt(2));
        System.out.println(Math.subtractExact(b,a));
        System.out.println(Math.pow(b,a));
        System.out.println(Math.random());
        System.out.println(Math.floorDiv(a,b));
        System.out.println(Math.floorMod(a,b));
        System.out.println(a - b * (a / b));
        System.out.println(-5/2);
```

### BigDecimal的使用

```java
double val = 4.23;
double val1 = 5.23;
BigDecimal decimal = new BigDecimal(val);
BigDecimal decimal1 = new BigDecimal(val1);
System.out.println(decimal.subtract(decimal1).setScale(2, RoundingMode.HALF_UP));
System.out.println(decimal.add(decimal1).setScale(2, RoundingMode.HALF_UP));
System.out.println(decimal.divide(decimal1,2,RoundingMode.HALF_UP));
System.out.println(decimal.multiply(decimal1).setScale(2,RoundingMode.HALF_UP));
```

八种舍入模式解释如下
1、ROUND_UP

舍入远离零的舍入模式。

在丢弃非零部分之前始终增加数字(始终对非零舍弃部分前面的数字加1)。

注意，此舍入模式始终不会减少计算值的大小。

2、ROUND_DOWN

接近零的舍入模式。

在丢弃某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截短)。

注意，此舍入模式始终不会增加计算值的大小。

3、ROUND_CEILING

接近正无穷大的舍入模式。

如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同;

如果为负，则舍入行为与 ROUND_DOWN 相同。

注意，此舍入模式始终不会减少计算值。

4、ROUND_FLOOR

接近负无穷大的舍入模式。

如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同;

如果为负，则舍入行为与 ROUND_UP 相同。

注意，此舍入模式始终不会增加计算值。

5、ROUND_HALF_UP

向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。

如果舍弃部分 >= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。

注意，这是我们大多数人在小学时就学过的舍入模式(四舍五入)。

6、ROUND_HALF_DOWN

向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。

如果舍弃部分 > 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。

7、ROUND_HALF_EVEN

向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。

如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;

如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。

注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。

此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。

如果前一位为奇数，则入位，否则舍去。

以下例子为保留小数点1位，那么这种舍入方式下的结果。

1.15>1.2 1.25>1.2

8、ROUND_UNNECESSARY

断言请求的操作具有精确的结果，因此不需要舍入。

如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。



<<<<<<< HEAD
=======

>>>>>>> 2e07c310e03c8f7ab4b022614225301dabe3ce72
[BigDecimal使用](https://www.cnblogs.com/zhangyinhua/p/11545305.html)
